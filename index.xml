<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BoseLiao&#39;s Blog</title>
    <link>https://boseliao.github.io/</link>
    <description>Recent content on BoseLiao&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 13 Jun 2020 18:16:09 +0800</lastBuildDate>
    
	<atom:link href="https://boseliao.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>QC:quantum_phase_estimation</title>
      <link>https://boseliao.github.io/posts/qcquantum_phase_estimation/</link>
      <pubDate>Sat, 13 Jun 2020 18:16:09 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qcquantum_phase_estimation/</guid>
      <description>quantum phase estimation(QPE) 量子相位估计算法应用了量子傅里叶逆变换，同时作为一个实用的基础量子算法，又被应用在Shor&amp;rsquo;s Algorithm（质因式分解算法），和HHL algorithm（经常用于各种量子机器学习的最优化算法）等等算法中。
假设有一个幺正算符U，具有本征态|u&amp;gt;，以及对应的本征值为e^(i\phi),(0&amp;lt;\phi的量子比特，你的选取将会影响得到\phi的精度以及得到正确本征值的概率。二，第二组寄存器需要足够量子比特存储态|u&amp;gt;。
由图可知，第一组寄存器的量子比特经过一个Hadmard门和C-U^{2^j}门 $$ |0\rangle\cdots|0\rangle|u\rangle\to Hadamard\to\frac{1}{\sqrt{2^n}}\left(|0\rangle+|1\rangle \right)\cdots\left(|0\rangle+|1\rangle \right)|u\rangle $$
$$ \to C-U^{2^j}\to\frac{1}{\sqrt{2^n}}\left(|0\rangle+e^{i2^{n-1}\phi}|1\rangle \right)\cdots\left(|0\rangle+e^{i\phi}|1\rangle \right)|u\rangle=\frac{1}{\sqrt{2^n}}\sum_{y=0}^{2^n-1}e^{i\phi y}|y\rangle |u\rangle $$
这里输出第一组寄存器中的\phi依赖于测量态的概率，但我们测量到的是态而非概率幅度，利用傅里叶变换可以将概率幅度存储的相位存储到量子态中。量子傅里叶逆变换为 $$ QFT^{-1}|y\rangle=\frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^{n}-1}\exp(-2\pi i\frac{xy}{2^n})|x\rangle $$ 将\phi写成 $$ \phi=2\pi\left(\frac{a}{2^n}+\delta \right),\quad a=a_{n-1}\cdots a_0,0&amp;lt;\delta|u&amp;gt;，可以得到本征值 $$ \phi=\frac{2\pi a}{2^n} $$ 当\delta不等于0时，则测到态|a&amp;gt;|u&amp;gt;的概率幅 $$ C_a=\frac{1}{2^n}\sum_{y=0}^{2^n-1}e^{2\pi i\delta y}&amp;gt;\frac{2}{\pi} $$
import numpy as np import matplotlib.pyplot as plt import qutip as qt from qutip.qip.circuit import QubitCircuit, Gate from qutip.qip import gates def user_gate1(): &amp;#34;&amp;#34;&amp;#34; define C-U:control-qubit=0,u=1;conrol-qubit=1,u=[[1.,0.],[0.,-1.]] &amp;#34;&amp;#34;&amp;#34; mat_control0=qt.</description>
    </item>
    
    <item>
      <title>QC:quantum_FourierT</title>
      <link>https://boseliao.github.io/posts/qcquantum_fouriert/</link>
      <pubDate>Mon, 08 Jun 2020 17:39:53 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qcquantum_fouriert/</guid>
      <description>在一些数学或计算科学问题中，傅里叶变换是一种非常常用的手段，用于将待解决的问题转换成已知的问题。 $$ \tilde{f}(k)=\frac{1}{\sqrt{N}}\sum_{j=0}^{N-1}\exp(2\pi i\frac{jk}{N})f(j) $$ 相应的量子傅里叶变换是将算符作用到某一态|j&amp;gt;上得到由一组正交归一的基|0&amp;gt;,...,|N-1&amp;gt;线性叠加的态， $$ F|j\rangle=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}\exp(2\pi i\frac{jk}{N})|k\rangle $$ 结合上面两个式子， $$ F\sum_{j=0}^{N-1}f(j)|j\rangle=\sum_{k=0}^{N-1}\tilde{f}(k)|k\rangle $$ 显然F的矩阵形式 $$ F_{kj}=\frac{1}{\sqrt{2^n}}\exp(2\pi i\frac{jk}{2^n}) $$ 如果有n个量子比特，则N=2^n，量子态可以写成 $$ |j\rangle=|j_{n-1},\cdots,j_0\rangle;j=j_{n-1}2^{n-1}+\cdots+j_02^0 $$
$$ |k\rangle=|k_{n-1},\cdots,k_0\rangle;k=k_{n-1}2^{n-1}+\cdots+k_02^0 $$
所以(2)式可以写成 $$ F|j_{n-1},\cdots,j_0\rangle=\frac{1}{\sqrt{2^n}}\sum_{k_{n-1}=0}^{1}\cdots\sum_{k_0=0}^{1}\exp(2\pi ij\sum_l\frac{2^lk_l}{2^n})|k_{n-1}\cdots k_0\rangle $$
$$ l\to n-l,=\frac{1}{\sqrt{2^n}}\otimes_{l=1}^{n}\sum_{k_{n-l}=0}^1\exp(2\pi ij\sum_l\frac{2^lk_l}{2^n})|k_{n-l}\rangle_{n-l}=\frac{1}{\sqrt{2^n}}\otimes_{l=1}^{n}\left(|0\rangle_{n-l}+e^{2\pi ij/2^l}|1\rangle_{n-l} \right) $$
由于 $$ e^{2\pi in}=1,e^{2\pi ij/2^l}=e^{2\pi i0.j_{l-1}\cdots j_0} $$
电路构造 Hadmard门 $$ H|j_{n-1}\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{j_{n-1}}|1\rangle \right)=\frac{1}{\sqrt{2}}\left(|0\rangle+e^{2\pi ij_{n-1}/2}|1\rangle \right) $$ C-R_k，受控相移门 $$ R_k=\left[\begin{array}{lr} 1 \quad 0 \newline \newline 0 \quad e^{\frac{2\pi i}{2^k}} \end{array}\right] $$ 量子傅里叶变换电路</description>
    </item>
    
    <item>
      <title>QC:quantum_algorithm</title>
      <link>https://boseliao.github.io/posts/qcquantum_algorithm/</link>
      <pubDate>Tue, 02 Jun 2020 07:46:20 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qcquantum_algorithm/</guid>
      <description>量子并行运算是一些量子算法中最基本的属性。它允许量子计算机对于不同的x能够同时计算f(x)。首先，考虑两个量子比特的幺正操作。 $$ U_f|x,y\rangle=|x,y\oplus f(x)\rangle $$ 其中，第一个寄存器储存自变量的数据，而第二个寄存器储存函数值。容易证明Uf操作总是一个幺正算符。 $$ \langle x\prime,y\prime|U_f|x,y\rangle=\langle x\prime,y\prime|x,y\oplus f(x)\rangle=\delta_{x\prime,x}\delta_{y\prime,y\oplus f(x)}=\delta_{x,x\prime}\delta_{y,y\prime\oplus f(x\prime)} $$
$$ =(\delta_{x,x\prime}\delta_{y,y\prime\oplus f(x\prime)})^*=(\langle x,y|U_f|x\prime,y\prime\rangle)^* $$
所以， $$ U_f=U_f^{\dagger} $$ 而 $$ U_f^2|x\rangle|y\rangle=|x\rangle|y\oplus f(x)\oplus f(x)\rangle=|x\rangle|y\rangle $$ 即 $$ U_f^2=1 $$ 任一二进制数可以表示为 $$ x=(x_{n-1},\cdots,x_0) $$ 对应的任一函数可以表示 $$ f(x^{(i)})=1,i=0,\cdots,m;f(x^{(i)})=0,i=m+1,\cdots,n-1 $$ 定义小项函数 $$ f^{(i)}(x)= \left[\begin{array}{lr} 1 \quad (x=x^{(i)}) \newline \newline 0 \quad (x \ne x^{(i)}) \end{array}\right. $$
则任一函数可以用小项函数来表示 $$ f(x)=f^{(1)}(x)\vee f^{(2)}(x)\vee\cdots f^{(m)}(x) $$ 每个小项函数对应于Cn-NOT操作。
量子加法器 对量子信息a和b进行加法，其进位储存在c $$ a=(a_{n-1},\cdots,a_0);b=(b_{n-1},\cdots,b_0);c=(c_{n},\cdots,c_0) $$ 量子加法器由两个模块组成，加法模块SUM(ai,bi,ci)和CARRY(ai,bi,ci)， $$ SUM(a_i,b_i,c_i):s_i=a_i\oplus b_i\oplus c_i $$</description>
    </item>
    
    <item>
      <title>QC:qubit_gate</title>
      <link>https://boseliao.github.io/posts/qcqubit_gate/</link>
      <pubDate>Wed, 27 May 2020 21:27:15 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qcqubit_gate/</guid>
      <description>利用一些装置可以实现对自旋态的操控，例如核磁共振(NMR)
单量子比特 sigma_x泡利算符X，对应于经典的NOT门 $$ \sigma_x|x\rangle=|1-x\rangle $$
from qutip.qip.circuit import QubitCircuit, Gate from qutip.qip import gates qc=QubitCircuit(N=1) def user_gate(): #sigma_x mat = np.array([[0.,1.0],[1., 0.]]) return qt.Qobj(mat, dims=[[2], [2]]) qc.user_gates={&amp;#34;sigma_x&amp;#34;:user_gate} qc.add_gate(&amp;#34;sigma_x&amp;#34;,targets=[0]) U_list = qc.propagators() from qutip.qip.operations import gate_sequence_product U = gate_sequence_product(U_list) psi0=qt.basis(2,0) psit=U*psi0 b=qt.Bloch() b.add_states(psi0) b.add_states(psit) b.save(&amp;#34;qc_gate.png&amp;#34;) b.show() sigma_z泡利算符Z $$ \sigma_z|x\rangle=(-1)^x|x\rangle $$
def user_gate(): #sigma_z mat = np.array([[1.,0.],[0., -1.]]) return qt.Qobj(mat, dims=[[2], [2]]) qc.user_gates={&amp;#34;sigma_z&amp;#34;:user_gate} qc.add_gate(&amp;#34;sigma_z&amp;#34;,targets=[0]) 旋转门(rotation gate) RX沿着X轴旋转 $$ R_x(\theta)(\alpha|0\rangle+\beta|1\rangle)=(\alpha\cos(\frac{\theta}{2})-i\beta\sin(\frac{\theta}{2}))|0\rangle+(\beta\cos(\frac{\theta}{2})-i\alpha\sin(\frac{\theta}{2}))|1\rangle $$</description>
    </item>
    
    <item>
      <title>QC:spin</title>
      <link>https://boseliao.github.io/posts/qcspin/</link>
      <pubDate>Tue, 26 May 2020 19:31:24 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qcspin/</guid>
      <description>磁偶极子在磁场中的势能 $$ H=U=-\mu B $$ \mu表示磁矩的大小和方向。磁偶极子受到的磁场梯度力为 $$ F=-\nabla U=\nabla (\mu B) $$ 自旋的磁矩可以表示为 $$ \mu =-\frac{1}{2}g\mu_B\sigma $$ 自旋在磁场中哈密顿量 $$ H=-\mu B=\frac{1}{2}g\mu_B\sigma B=\frac{1}{2}\hbar\gamma\sigma B $$ 著名的Stern-Gerlach实验证明了自旋磁矩的量子化
在图中，电子经过第一个SG装置会分裂成两部分|n+&amp;gt;和|n-&amp;gt;，之后 |n+&amp;gt;经过第二个SG装置继续分成两部分|m+&amp;gt;和|m-&amp;gt;， $$ P(|n+\rangle\to|m+\rangle)=\frac{1}{2}\left(1+nm \right) $$
$$ P(|n+\rangle\to|m-\rangle)=\frac{1}{2}\left(1-nm \right) $$
选择Z方向的本征态为基失 $$ |Z+\rangle=|0\rangle ,|Z-\rangle=|1\rangle $$ 则 $$ |n+\rangle=\alpha|0\rangle+\beta|1\rangle $$ 将m设置为Z方向 $$ P(|n+\rangle\to|0\rangle)=\frac{1}{2}\left(1+nZ \right)=|\alpha|^2 $$ 在球坐标中 $$ n=(sin(\theta)cos(\phi),sin(\theta)sin(\phi),cos(\theta)) $$ 任一量子态可以写成 $$ |n+\rangle=cos(\theta/2)|0\rangle+sin(\theta/2)e^{i\phi}|1\rangle $$ 在Bloch球中表示任一量子态
b=qt.Bloch() pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)] b.add_points(pnt) vec = [0,1,0] b.add_vectors(vec) b.show() 不难证明n方向的角动量 $$ S(n)=n\sigma=n_x\sigma_x+n_y\sigma_y+n_z\sigma_z $$ 考虑自旋在磁场中的时间演化，哈密顿量写成 $$ H=\frac{1}{2}\hbar\gamma\sigma_zB_z $$ 设初态处于 $$ |\psi(0)\rangle=\alpha|0\rangle+\beta|1\rangle $$ 时间演化 $$ |\psi(t)\rangle=e^{-i\gamma B_z\sigma_z/2}(\alpha|0\rangle+\beta|1\rangle)=\alpha|0\rangle+\beta e^{i\gamma B_zt}|1\rangle $$ </description>
    </item>
    
    <item>
      <title>QuTip:spin_chain</title>
      <link>https://boseliao.github.io/posts/qutipspin_chain/</link>
      <pubDate>Mon, 25 May 2020 17:50:07 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qutipspin_chain/</guid>
      <description>考虑一维的ISing模型，其哈密顿量， $$ \begin{equation} H=-\frac{1}{2}\sum_n^Nh_n\sigma_z(n)-\frac{1}{2}\sum_n^{N-1}\sum_{i=x,y,z}J_i^{(n)}\sigma_i(n)\sigma_i(n+1) \end{equation} $$ 利用主方程计算其动力学的演化
def integrate(N,h,Jx,Jy,Jz,psi0,tlist,gamma,solver): si=qt.qeye(2) sx=qt.sigmax() sy=qt.sigmay() sz=qt.sigmaz() sx_list=[] sy_list=[] sz_list=[] #construct sigma_x(n),sigma_y(n),sigma_z(n)  for n in range(N): op_list=[] for m in range(N): op_list.append(si) op_list[n] = sx sx_list.append(qt.tensor(op_list)) op_list[n] = sy sy_list.append(qt.tensor(op_list)) op_list[n] = sz sz_list.append(qt.tensor(op_list)) # construct the hamiltonian H = 0 # energy splitting terms for n in range(N): H += - 0.5 * h[n] * sz_list[n] # interaction terms for n in range(N-1): H += - 0.</description>
    </item>
    
    <item>
      <title>QuTip:HEOM</title>
      <link>https://boseliao.github.io/posts/qutipheom/</link>
      <pubDate>Wed, 20 May 2020 16:20:42 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qutipheom/</guid>
      <description>级联运动方程是用于计算非马尔科夫动力学的最普遍的工具，
$$\frac{\partial}{\partial t}\rho^n_{j_1\dots j_K}=-\left[iH_s^{\times}+n\gamma+\sum_{k=1}^Kj_k\nu_k-\Xi \right]\rho^n_{j_1\dots j_K}+V^{\times}\rho^{n+1}_{j_1\dots j_K}$$
$$V^{\times}\sum_{k=1}^K\rho^n_{j_1\dots j_k+1\dots J_K}+n\Theta\rho^{n-1}_{j_1\dots J_K}+\sum_{k=1}^Kj_k\nu_k\Psi_k\rho^n_{j_1\dots j_k-1\dots j_K }$$
其中$\rho^n_{j_1\dots jK}$表示n阶辅助密度矩阵，对它的求解依赖于n+1，n-1，n阶辅助矩阵，即此方程是不封闭的。而最后要求得的真正的约化密度矩阵是$\rho^0{0\dots 0}$，见图假设（K=2）
由图可知，可以做如下截断N=n=j1+...+jK，截断方程
$$\frac{\partial}{\partial t}\rho^n_{j_1\dots j_K}=-\left[iH_s^{\times}-\Xi \right]\rho^n_{j_1\dots j_K}$$
这里，目前只能求解洛伦兹谱的谱密度$$J(\omega)=\frac{\eta}{2\pi}\frac{\omega\gamma^2}{\gamma^2+\omega^2}$$其中$\eta$是“system-bath coupling strength”，$\gamma$表示&amp;rdquo;Bath spectral density cutoff frequency&amp;rdquo;。
这里对文献Non-Markovian and Non-Perturbative Entanglement Dynamics of Biomolecular Excitons进行了follow，
import numpy as np import matplotlib.pyplot as plt import qutip as qt from qutip.nonmarkov import heom &amp;#34;&amp;#34;&amp;#34; initial attribution self.configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann, renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats) H_sys : Qobj System Hamiltonian coup_op : Qobj Operator describing the coupling between system and bath.</description>
    </item>
    
    <item>
      <title>QuTip:time_correlation</title>
      <link>https://boseliao.github.io/posts/qutiptime_correlation/</link>
      <pubDate>Tue, 19 May 2020 19:12:13 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qutiptime_correlation/</guid>
      <description>QuTip计算时间关联函数$$\langle A(t+\tau)B(t)\rangle$$可以使用以下三种态演化方程：Master-equation, Exponential series， the Monte-Carlo。
&amp;#34;&amp;#34;&amp;#34; correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver=&amp;#39;me&amp;#39;, reverse=False, args={}, options=&amp;lt;qutip.solver.Options object at 0xa7eedc2c&amp;gt;) ----- state0 : Initial state density matrix or state vector. If &amp;#39;state0&amp;#39; is &amp;#39;None&amp;#39;, then the steady state will be used as the initial state. c_ops : list of collapse operators, may be time-dependent a_op : operator A b_op : operator B. reverse : bool {False, True} If `True`, calculate :math:`\left&amp;lt;A(t)B(t+\tau)\right&amp;gt;` instead of :math:`\left&amp;lt;A(t+\tau)B(t)\right&amp;gt;`.</description>
    </item>
    
    <item>
      <title>QuTip:含时系统</title>
      <link>https://boseliao.github.io/posts/qutip%E5%90%AB%E6%97%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 18 May 2020 15:10:50 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qutip%E5%90%AB%E6%97%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>前面已经简单的介绍过关于含时Lindblad主方程的求解，以及含时的哈密顿量和跃迁算符的表示。相应的，Bloch-Redfield含时的主方程也可以做类似求解，
kappe=0.5 def co1_coeff(t,args): return np.sqrt(kappe*np.exp(-t)) N=10 a=qt.destroy(N) H0=a.dag()*a H1=a+a.dag() def H1_coeff(t,args): return 9*np.exp(-(t/5.0)**2) H=[H0,[H1,H1_coeff]] psi0=qt.basis(N,9) c_ops=[a,[a,co1_coeff]] times=np.linspace(0.0,10.0,100) output=qt.mesolve(H,psi0,times,c_ops,[a.dag()*a]) #time-dependt Lindblad equation a_ops=[[(a,a.dag()),(&amp;#39;{0}*(w&amp;gt;0)&amp;#39;.format(kappe),&amp;#39;exp(1j*t)&amp;#39;,&amp;#39;exp(-1j*t)&amp;#39;)]] out2=qt.brmesolve(H0,psi0,times,a_ops,e_ops=[a.dag()*a]) #time-dependt Redfield equation 除此之外，当含时的参数是非解析的函数或者由实验得到的数据点时，需要将数据点变成函数。
t=np.linspace(-15,15,100) func=lambda t: 9*np.exp(-(t/5)**2) #anonymous functions noisy_func=lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]) #generary a random array shape like t,Standard normal distribution noisy_data=noisy_func(t) S=qt.interpolate.Cubic_Spline(t[0],t[-1],noisy_data) H=[[H1,S]] 含时算符的指数级数表示$$\hat{A}=\sum_i\hat{a}e^{r_it}$$
&amp;#34;&amp;#34;&amp;#34; Exponential-series representation &amp;#34;&amp;#34;&amp;#34; es1=qt.eseries(qt.sigmax(),1j) #sigma_x*exp(jt) es2=qt.eseries([qt.sigmax(),qt.sigmax()],[1j,-1j])#sigms_x*exp(jt)+sigma_xexp(-jt) &amp;#34;&amp;#34;&amp;#34; evaluate it at time t=2 &amp;#34;&amp;#34;&amp;#34; qt.esval(es2,2.0) Floquet理论 在Lindblad和Bloch-Redfield主方程的标准推导中，所考虑的系统是不显含时时间的。因此，严格地说，这些主方程形式不应盲目地应用于含时哈密顿量的系统。然而，在许多特定的情况下，特别是对于弱驱动的情况，标准主方程仍然适用于许多含时的问题。但更严格的方法是从含时的哈密顿量开始重新推导主方程。Floquet-Markov主方程是这样一种形式的主方程，它在强驱动系统中有着重要的应用。
封闭系统的Floquet计算方法$$\psi(t)=\sum_{\alpha}c_{\alpha}\psi_{\alpha}(t)=\sum_{\alpha}c_{\alpha}e^{-i\epsilon_{\alpha}t}\phi_{\alpha}(t)$$
其中\psi_{\alpha}​表示“Floquet state”，\phi_{\alpha}表示周期的“Floquet mode”，\phi_{\alpha}(t+T)=\phi_{\alpha}(t)​，\epsilon_{\alpha}表示常数“quasienergy”</description>
    </item>
    
    <item>
      <title>QuTip的基本运算</title>
      <link>https://boseliao.github.io/posts/qutip%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 15 May 2020 13:21:41 +0800</pubDate>
      
      <guid>https://boseliao.github.io/posts/qutip%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</guid>
      <description>QuTip (Quantum Toolbox in Python) 是在开源的Python程序语音的框架下，用来模拟量子系统的动力学。其中，定义了一般的量子力学对象，运算算符，以及量子力学方程的求解方法。使用下列代码时，请调用QuTip模块，并使用如下语句
import numpy as np import matplotlib.pyplot as plt import qutip as qt 首先，QuTip 定义了量子对象类(The quantum object class)，可以通过输入命令Qobj(),创建一个空的量子对象。Qobj()类中拥有5个属性，
 Type：ket，bra，operator，superoperator，operator-ket，operator-bra Data：数组 Hermitian：false，ture Dimensions：算符的维度 Shape：数组的形状  具体对象，态的定义 量子态的定义可以通过phi=Qobj([[1],[2],[3]])来得到ket或者bra的态失，也可以通过rho=ket2dm(phi)得到密度矩阵。这里也定义了一些特殊态，Fock state，basis(N,m)或者fock(N,m);相干态，coherence(N,alpha)。具体函数的输入以及参数的使用，可以利用help(basis)查看。
算符的定义 量子算符按照是否可观测可分为Hermitian算符与non-Hermitian算符，可以定义
r=np.array([[1,2],[3,4]]) Qobj(r) 其中也定义了一些常用的算符：
   operator command     Commutator commutator(A,B,kind)   sigma-X sigmax()   Lowing operator destroy(N)    等等。。。
超算符 在Liouville空间中，算符在处理时被视为向量，可以通过
vec_rho=operator_to_vector(rho) rho=vector_to_operator(vec_rho) 超算符
X=sigmax() S=spre(X) #I tensor X S1=spost(X) # X tensor I S2=spre(X)*spost(X.</description>
    </item>
    
  </channel>
</rss>