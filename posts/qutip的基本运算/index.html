<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">

<meta itemprop="name" content="QuTip的基本运算">
<meta itemprop="description" content="QuTip (Quantum Toolbox in Python) 是在开源的Python程序语音的框架下，用来模拟量子系统的动力学。其中，定义了一般的量子力学对象，运算算符，以及量子力学方程的求解方法。使用下列代码时，请调用QuTip模块，并使用如下语句
import numpy as np import matplotlib.pyplot as plt import qutip as qt 首先，QuTip 定义了量子对象类(The quantum object class)，可以通过输入命令Qobj(),创建一个空的量子对象。Qobj()类中拥有5个属性，
 Type：ket，bra，operator，superoperator，operator-ket，operator-bra Data：数组 Hermitian：false，ture Dimensions：算符的维度 Shape：数组的形状  具体对象，态的定义 量子态的定义可以通过phi=Qobj([[1],[2],[3]])来得到ket或者bra的态失，也可以通过rho=ket2dm(phi)得到密度矩阵。这里也定义了一些特殊态，Fock state，basis(N,m)或者fock(N,m);相干态，coherence(N,alpha)。具体函数的输入以及参数的使用，可以利用help(basis)查看。
算符的定义 量子算符按照是否可观测可分为Hermitian算符与non-Hermitian算符，可以定义
r=np.array([[1,2],[3,4]]) Qobj(r) 其中也定义了一些常用的算符：
   operator command     Commutator commutator(A,B,kind)   sigma-X sigmax()   Lowing operator destroy(N)    等等。。。
超算符 在Liouville空间中，算符在处理时被视为向量，可以通过
vec_rho=operator_to_vector(rho) rho=vector_to_operator(vec_rho) 超算符
X=sigmax() S=spre(X) #I tensor X S1=spost(X) # X tensor I S2=spre(X)*spost(X.">


<meta itemprop="datePublished" content="2020-05-15T13:21:41&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-15T13:21:41&#43;08:00" />
<meta itemprop="wordCount" content="332">



<meta itemprop="keywords" content="QuTip," />
<meta property="og:title" content="QuTip的基本运算" />
<meta property="og:description" content="QuTip (Quantum Toolbox in Python) 是在开源的Python程序语音的框架下，用来模拟量子系统的动力学。其中，定义了一般的量子力学对象，运算算符，以及量子力学方程的求解方法。使用下列代码时，请调用QuTip模块，并使用如下语句
import numpy as np import matplotlib.pyplot as plt import qutip as qt 首先，QuTip 定义了量子对象类(The quantum object class)，可以通过输入命令Qobj(),创建一个空的量子对象。Qobj()类中拥有5个属性，
 Type：ket，bra，operator，superoperator，operator-ket，operator-bra Data：数组 Hermitian：false，ture Dimensions：算符的维度 Shape：数组的形状  具体对象，态的定义 量子态的定义可以通过phi=Qobj([[1],[2],[3]])来得到ket或者bra的态失，也可以通过rho=ket2dm(phi)得到密度矩阵。这里也定义了一些特殊态，Fock state，basis(N,m)或者fock(N,m);相干态，coherence(N,alpha)。具体函数的输入以及参数的使用，可以利用help(basis)查看。
算符的定义 量子算符按照是否可观测可分为Hermitian算符与non-Hermitian算符，可以定义
r=np.array([[1,2],[3,4]]) Qobj(r) 其中也定义了一些常用的算符：
   operator command     Commutator commutator(A,B,kind)   sigma-X sigmax()   Lowing operator destroy(N)    等等。。。
超算符 在Liouville空间中，算符在处理时被视为向量，可以通过
vec_rho=operator_to_vector(rho) rho=vector_to_operator(vec_rho) 超算符
X=sigmax() S=spre(X) #I tensor X S1=spost(X) # X tensor I S2=spre(X)*spost(X." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://boseliao.github.io/posts/qutip%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/" />
<meta property="article:published_time" content="2020-05-15T13:21:41&#43;08:00"/>
<meta property="article:modified_time" content="2020-05-15T13:21:41&#43;08:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="QuTip的基本运算"/>
<meta name="twitter:description" content="QuTip (Quantum Toolbox in Python) 是在开源的Python程序语音的框架下，用来模拟量子系统的动力学。其中，定义了一般的量子力学对象，运算算符，以及量子力学方程的求解方法。使用下列代码时，请调用QuTip模块，并使用如下语句
import numpy as np import matplotlib.pyplot as plt import qutip as qt 首先，QuTip 定义了量子对象类(The quantum object class)，可以通过输入命令Qobj(),创建一个空的量子对象。Qobj()类中拥有5个属性，
 Type：ket，bra，operator，superoperator，operator-ket，operator-bra Data：数组 Hermitian：false，ture Dimensions：算符的维度 Shape：数组的形状  具体对象，态的定义 量子态的定义可以通过phi=Qobj([[1],[2],[3]])来得到ket或者bra的态失，也可以通过rho=ket2dm(phi)得到密度矩阵。这里也定义了一些特殊态，Fock state，basis(N,m)或者fock(N,m);相干态，coherence(N,alpha)。具体函数的输入以及参数的使用，可以利用help(basis)查看。
算符的定义 量子算符按照是否可观测可分为Hermitian算符与non-Hermitian算符，可以定义
r=np.array([[1,2],[3,4]]) Qobj(r) 其中也定义了一些常用的算符：
   operator command     Commutator commutator(A,B,kind)   sigma-X sigmax()   Lowing operator destroy(N)    等等。。。
超算符 在Liouville空间中，算符在处理时被视为向量，可以通过
vec_rho=operator_to_vector(rho) rho=vector_to_operator(vec_rho) 超算符
X=sigmax() S=spre(X) #I tensor X S1=spost(X) # X tensor I S2=spre(X)*spost(X."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>QuTip的基本运算</title>
	<link rel="stylesheet" href="https://boseliao.github.io/css/style.min.657bcb7af31123e4156b1a3d2ff60a636717e54ead74f882136b5114cf72b55e.css" integrity="sha256-ZXvLevMRI+QVaxo9L/YKY2cX5U6tdPiCE2tRFM9ytV4=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://boseliao.github.io">BoseLiao&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://boseliao.github.io/posts/">Posts</a>
				<a href="https://boseliao.github.io/boseliao">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://boseliao.github.io/posts/">Posts</a></li>
			<li><a href="https://boseliao.github.io/boseliao">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>May 15, 2020</span></div>
				<h1>QuTip的基本运算</h1>
			</header>
			<div class="content">
				

<p>QuTip (Quantum Toolbox in Python) 是在开源的Python程序语音的框架下，用来模拟量子系统的动力学。其中，定义了一般的量子力学对象，运算算符，以及量子力学方程的求解方法。使用下列代码时，请调用QuTip模块，并使用如下语句</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span></code></pre></div>
<hr />

<p>首先，QuTip 定义了量子对象类(The quantum object class)，可以通过输入命令<code>Qobj()</code>,创建一个空的量子对象。<code>Qobj()</code>类中拥有5个属性，</p>

<ul>
<li>Type：ket，bra，operator，superoperator，operator-ket，operator-bra</li>
<li>Data：数组</li>
<li>Hermitian：false，ture</li>
<li>Dimensions：算符的维度</li>
<li>Shape：数组的形状</li>
</ul>

<h2 id="具体对象-态的定义">具体对象，态的定义<a href="#具体对象-态的定义" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>量子态的定义可以通过<code>phi=Qobj([[1],[2],[3]])</code>来得到ket或者bra的态失，也可以通过<code>rho=ket2dm(phi)</code>得到密度矩阵。这里也定义了一些特殊态，Fock state，<code>basis(N,m)</code>或者<code>fock(N,m)</code>;相干态，<code>coherence(N,alpha)</code>。具体函数的输入以及参数的使用，可以利用<code>help(basis)</code>查看。</p>

<h2 id="算符的定义">算符的定义<a href="#算符的定义" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>量子算符按照是否可观测可分为Hermitian算符与non-Hermitian算符，可以定义</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">r</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">Qobj</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code></pre></div>
<p>其中也定义了一些常用的算符：</p>

<table>
<thead>
<tr>
<th align="center">operator</th>
<th align="center">command</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Commutator</td>
<td align="center">commutator(A,B,kind)</td>
</tr>

<tr>
<td align="center">sigma-X</td>
<td align="center">sigmax()</td>
</tr>

<tr>
<td align="center">Lowing operator</td>
<td align="center">destroy(N)</td>
</tr>
</tbody>
</table>

<p>等等。。。</p>

<h2 id="超算符">超算符<a href="#超算符" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>在Liouville空间中，算符在处理时被视为向量，可以通过</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">vec_rho</span><span class="o">=</span><span class="n">operator_to_vector</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="n">rho</span><span class="o">=</span><span class="n">vector_to_operator</span><span class="p">(</span><span class="n">vec_rho</span><span class="p">)</span></code></pre></div>
<p>超算符</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">X</span><span class="o">=</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">S</span><span class="o">=</span><span class="n">spre</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1">#I tensor X</span>
<span class="n">S1</span><span class="o">=</span><span class="n">spost</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># X tensor I</span>
<span class="n">S2</span><span class="o">=</span><span class="n">spre</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">spost</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span></code></pre></div>
<p>其中S2也可以表达成</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">S2</span><span class="o">=</span><span class="n">to_super</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></code></pre></div>
<p>超算符可以表达成Kraus和形式</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">to_kraus</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span></code></pre></div>
<p>超算符正定性的验证</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">S</span><span class="o">.</span><span class="n">iscp</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">istp</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">iscptp</span></code></pre></div>
<h2 id="算符函数">算符函数<a href="#算符函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>QuTip也提供了一些算符的函数：</p>

<table>
<thead>
<tr>
<th>Function</th>
<th>Command</th>
<th>Desciption</th>
</tr>
</thead>

<tbody>
<tr>
<td>Conjugate</td>
<td>Q.conj()</td>
<td>Conjugate of quantum operator,Q represent Qobj</td>
</tr>

<tr>
<td>Dagger</td>
<td>Q.dag()</td>
<td></td>
</tr>

<tr>
<td>Diagonal</td>
<td>Q.diag()</td>
<td></td>
</tr>

<tr>
<td>Eigenstate</td>
<td>Q.eigenstates()</td>
<td>return eigenvector and eigenvalue</td>
</tr>

<tr>
<td>Trace</td>
<td>Q.tr()</td>
<td></td>
</tr>

<tr>
<td>Partial trace</td>
<td>Q.ptrace()</td>
<td></td>
</tr>

<tr>
<td>Transpose</td>
<td>Q.trans()</td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="薛定谔方程">薛定谔方程<a href="#薛定谔方程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>在close量子系统中，量子态的时间演化可以通过薛定谔方程求解。<u>以下代码用qt代表qutip</u></p>

<p>$$ih\frac{\partial}{\partial t}\psi (t)=H\psi (t)$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">H</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.1</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="n">result</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()])</span></code></pre></div>
<p>H表示哈密顿量，psi0表示处于初态，time表示数值计算的时间序列，最后一个参数<code>[qt.sigmaz()]</code>表示输出该算符的平均值。</p>

<p>类似于<code>Qobj()</code>，求解方程得到的输出result属于<code>qutip.solver.Result</code>定义的类。他也具有一些重要的属性，</p>

<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>result.times</td>
<td>List/array of times at which simulation data is calculated.</td>
</tr>

<tr>
<td>result.expect</td>
<td>List/array of expectation values</td>
</tr>

<tr>
<td>result.states</td>
<td>List/array of state vectors/density matrices calculated at times</td>
</tr>
</tbody>
</table>

<p>将结果可视化，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">times</span><span class="p">,</span><span class="n">result</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Times&#39;</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;expactation value&#39;</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s2">&#34;sigma_z&#34;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p>含时量子系统的表示以及求解，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">H0</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.1</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="n">H1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="n">A</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
    <span class="n">sig</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">sig</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>
<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="mf">9.0</span><span class="p">,</span><span class="s1">&#39;sigma&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">}</span>
<span class="n">result</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()],</span><span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span></code></pre></div>
<p>其中H0是不含时部分，H1的含时部分用函数描述，即<code>H=H0+f(t)*H1</code>。对应的任一含时算符都可以这样表示。<code>A</code>与<code>sig</code>表示模拟计算中可变的参数。</p>

<h2 id="lindblad主方程">Lindblad主方程<a href="#lindblad主方程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>量子开放系统的动力学常常需要利用主方程描述，其中最重要的形式是Lindblad形式。对于Linblad主方程的求解，其中C_n表示跃迁算符(collapse operation)</p>

<p>$$\dot{\rho}=-\frac{i}{h}\left[H,\rho \right]+\sum_n\frac{1}{2}\left[2C_n\rho(t)C_n^{\dagger}-\rho(t)C_n^{\dagger}C_n-C_n^{\dagger}C_n\rho(t) \right]$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Lindblad equation(use mesolve())
</span><span class="s2">H:Hamiltonian
</span><span class="s2">psi0:initial state
</span><span class="s2">time:time list
</span><span class="s2">c_ops:a list of collapse operation
</span><span class="s2">return the expect value of operator
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">time2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">result2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time2</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>\
                                 <span class="p">,</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">()])</span></code></pre></div>
<p>其中，<code>mesolve</code>函数中第四个参数<code>c_ops</code>表示Lindblad主方程中的跃迁算符。利用蒙特卡洛方法求解Lindblad主方程</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">monte carlo
</span><span class="s2">advantage:keep state vector rather density matrix
</span><span class="s2">error=1/ntraj
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">result3</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time2</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>\
                                 <span class="p">,</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">()],</span><span class="n">ntraj</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span></code></pre></div>
<p>对于求解大量粒子的系统，蒙特卡洛方法在计算时间以及内存的使用上具有更大的优势，其误差正比于<code>1/ntraj</code>。</p>

<p>这里介绍的求解Lindblad主方程的两种方法都可以用来求解含时的哈密顿量，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">ustate</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">excited</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ground</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">N</span><span class="o">=</span><span class="mi">2</span> <span class="c1">#dimension of cavity</span>
<span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span> <span class="c1">#define time vector</span>
<span class="n">sigma_ge</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">ground</span><span class="o">*</span><span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="c1">#|g&gt;&lt;e|</span>
<span class="n">sigma_ue</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">ustate</span><span class="o">*</span><span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="c1">#|u&gt;&lt;e|</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ada</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">C_ops</span><span class="o">=</span><span class="p">[]</span> <span class="c1">#build a collapse operators</span>
<span class="n">Kappa</span><span class="o">=</span><span class="mf">1.5</span> <span class="c1">#Cavity decay rate</span>
<span class="n">C_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Kappa</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">gamma</span><span class="o">=</span><span class="mf">6.0</span> <span class="c1">#Atomic decay rate</span>
<span class="n">C_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">*</span><span class="n">sigma_ue</span><span class="p">)</span> <span class="c1">#5/9 e--&gt;u</span>
<span class="n">C_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">*</span><span class="n">sigma_ge</span><span class="p">)</span> <span class="c1">#4/9 e--&gt;g</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">ustate</span><span class="p">)</span> <span class="c1">#define initial state</span>
<span class="n">state_GG</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">ground</span><span class="p">)</span> <span class="c1">#define state onto which to project</span>
<span class="n">sigma_GG</span><span class="o">=</span><span class="n">state_GG</span><span class="o">*</span><span class="n">state_GG</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">state_UU</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">ustate</span><span class="p">)</span>
<span class="n">sigma_UU</span><span class="o">=</span><span class="n">state_UU</span><span class="o">*</span><span class="n">state_UU</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">g</span><span class="o">=</span><span class="mi">5</span> <span class="c1">#couple strength</span>
<span class="n">H0</span><span class="o">=-</span><span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">sigma_ge</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sigma_ue</span><span class="p">)</span> <span class="c1">#time-independent term</span>
<span class="n">H1</span><span class="o">=</span><span class="n">sigma_ue</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">+</span><span class="n">sigma_ue</span>
<span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="mf">5.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>
<span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">C_ops</span><span class="p">,[</span><span class="n">ada</span><span class="p">,</span><span class="n">sigma_UU</span><span class="p">,</span><span class="n">sigma_GG</span><span class="p">])</span></code></pre></div>
<h2 id="bloch-redfield方程">Bloch-Redfield方程<a href="#bloch-redfield方程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>Bloch-Redfield方程是主方程的矩阵元表现形式，对其求解可以先求出Redfield张量，再求解方程</p>

<p>$$\dot{\rho}_{ab}=-i\omega_{ab}\rho_{ab}+\sum_{cd}R_{abcd}\rho_{cd}$$</p>

<p>其中</p>

<p>$$R_{abcd}=-\frac{1}{2}\sum_{\alpha\beta}\left[\delta_{bd}\sum_nA^{\alpha}_{an}A^{\beta}_{nc}S_{\alpha\beta}(\omega_{cn})-A^{\alpha}_{ac}A^{\beta}_{db}S_{\alpha\beta}(\omega_{ca})\right.$$</p>

<p>$$\left.+\delta_{ac}\sum_nA^{\alpha}_{dn}A^{\beta}_{nb}S_{\alpha\beta}(\omega_{dn})+A^{\alpha}_{ac}A^{\beta}_{db}S_{\alpha\beta}(\omega_{db}) \right]$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Bloch redfield
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">eps0</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">gamma1</span><span class="o">=</span><span class="mf">0.5</span>
<span class="n">H</span><span class="o">=-</span><span class="n">delta</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">-</span><span class="n">eps0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">ohmic_spectrum</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">w</span><span class="o">==</span><span class="mf">0.0</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">gamma1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gamma1</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">R</span><span class="p">,</span><span class="n">ekets</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">bloch_redfield</span><span class="o">.</span><span class="n">bloch_redfield_tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,[[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">ohmic_spectrum</span><span class="p">]])</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">R:Bloch-Redfiled tensor
</span><span class="s2">ekets:eigenket of H
</span><span class="s2">ohmic_spectrum:2.0*Gamma(w)
</span><span class="s2">sigmax():the operator coupled with environment
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">tlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">rand_ket</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">e_ops</span><span class="o">=</span><span class="p">[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()]</span>
<span class="n">expt_list</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">bloch_redfield_solve</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">ekets</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,</span><span class="n">e_ops</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Bloch sphere
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">sphere</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Bloch</span><span class="p">()</span> <span class="c1">#create a Bloch sphere</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">add_points</span><span class="p">([</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span> <span class="c1">#add 3d point&#39; position</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">vector_color</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">add_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delta</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">eps0</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">eps0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1">#add vector</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">make_sphere</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p>最后在布洛赫球上对解进行可视化。类似于Lindblad方程，也可以直接求解</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">brmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,</span><span class="n">a_ops</span><span class="o">=</span><span class="p">[[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">ohmic_spectrum</span><span class="p">]]</span>\
                                         <span class="p">,</span><span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">)</span></code></pre></div>
<p>值得注意的是第一种方法的解<code>expt_list</code>并不属于<code>qutip.solver.Result</code>类，只是单纯存储着数组（算符的平均值），而第二种解是完全类似与Lindblad方程解的结构。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://boseliao.github.io/tags/qutip">QuTip</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>332 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-05-15 13:21 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://boseliao.github.io/posts/qutip%E5%90%AB%E6%97%B6%E7%B3%BB%E7%BB%9F/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>QuTip:含时系统</span>
			</a>
			<a class="prev-post" href="https://boseliao.github.io/posts/qutip%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>QuTip的安装与配置</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://boseliao.github.io">BoseLiao</a> &#183; <a hr#ef="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">All rights reserved</a></p>
	</footer>



	<script src="https://boseliao.github.io/js/bundle.min.490e43e5af6db5906f28afa49a4e16bf9f626b758e3fca92f146b870eb94bb37.js" integrity="sha256-SQ5D5a9ttZBvKK+kmk4Wv59ia3WOP8qS8Ua4cOuUuzc=" crossorigin="anonymous"></script>
	

</body>

</html>
