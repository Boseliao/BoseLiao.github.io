<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on BoseLiao&#39;s Blog</title>
		<link>https://boseliao.github.io/posts/</link>
		<description>Recent content in Posts on BoseLiao&#39;s Blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 18 May 2020 15:10:50 +0800</lastBuildDate>
		<atom:link href="https://boseliao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>QuTip:含时系统</title>
			<link>https://boseliao.github.io/posts/qutip%E5%90%AB%E6%97%B6%E7%B3%BB%E7%BB%9F/</link>
			<pubDate>Mon, 18 May 2020 15:10:50 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qutip%E5%90%AB%E6%97%B6%E7%B3%BB%E7%BB%9F/</guid>
			<description>前面已经简单的介绍过关于含时Lindblad主方程的求解，以及含时的哈密顿量和跃迁算符的表示。相应的，Bloch-Redfield含时的主方程也可以做类似求解，
kappe=0.5 def co1_coeff(t,args): return np.sqrt(kappe*np.exp(-t)) N=10 a=qt.destroy(N) H0=a.dag()*a H1=a+a.dag() def H1_coeff(t,args): return 9*np.exp(-(t/5.0)**2) H=[H0,[H1,H1_coeff]] psi0=qt.basis(N,9) c_ops=[a,[a,co1_coeff]] times=np.linspace(0.0,10.0,100) output=qt.mesolve(H,psi0,times,c_ops,[a.dag()*a]) #time-dependt Lindblad equation a_ops=[[(a,a.dag()),(&amp;#39;{0}*(w&amp;gt;0)&amp;#39;.format(kappe),&amp;#39;exp(1j*t)&amp;#39;,&amp;#39;exp(-1j*t)&amp;#39;)]] out2=qt.brmesolve(H0,psi0,times,a_ops,e_ops=[a.dag()*a]) #time-dependt Redfield equation 除此之外，当含时的参数是非解析的函数或者由实验得到的数据点时，需要将数据点变成函数。
t=np.linspace(-15,15,100) func=lambda t: 9*np.exp(-(t/5)**2) #anonymous functions noisy_func=lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]) #generary a random array shape like t,Standard normal distribution noisy_data=noisy_func(t) S=qt.interpolate.Cubic_Spline(t[0],t[-1],noisy_data) H=[[H1,S]] 含时算符的指数级数表示$\hat{A}=\sum_i\hat{a}e^{r_it}$，
&amp;#34;&amp;#34;&amp;#34; Exponential-series representation &amp;#34;&amp;#34;&amp;#34; es1=qt.eseries(qt.sigmax(),1j) #sigma_x*exp(jt) es2=qt.eseries([qt.sigmax(),qt.sigmax()],[1j,-1j])#sigms_x*exp(jt)+sigma_xexp(-jt) &amp;#34;&amp;#34;&amp;#34; evaluate it at time t=2 &amp;#34;&amp;#34;&amp;#34; qt.esval(es2,2.0) Floquet理论 在Lindblad和Bloch-Redfield主方程的标准推导中，所考虑的系统是不显含时时间的。因此，严格地说，这些主方程形式不应盲目地应用于含时哈密顿量的系统。然而，在许多特定的情况下，特别是对于弱驱动的情况，标准主方程仍然适用于许多含时的问题。但更严格的方法是从含时的哈密顿量开始重新推导主方程。Floquet-Markov主方程是这样一种形式的主方程，它在强驱动系统中有着重要的应用。
封闭系统的Floquet计算方法$\psi(t)=\sum{\alpha}c{\alpha}\psi{\alpha}(t)=\sum{\alpha}c{\alpha}e^{-i\epsilon{\alpha}t}\phi{\alpha}(t)$，其中$\psi{\alpha}$表示“Floquet state”，$\phi{\alpha}$表示周期的“Floquet mode”，$\phi{\alpha}(t+T)=\phi{\alpha}(t)$，$\epsilon{\alpha}$表示常数“quasienergy”</description>
			<content type="html"><![CDATA[

<p>前面已经简单的介绍过关于含时Lindblad主方程的求解，以及含时的哈密顿量和跃迁算符的表示。相应的，Bloch-Redfield含时的主方程也可以做类似求解，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">kappe</span><span class="o">=</span><span class="mf">0.5</span>
<span class="k">def</span> <span class="nf">co1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappe</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>
<span class="n">N</span><span class="o">=</span><span class="mi">10</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">H0</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span>
<span class="n">H1</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="mf">5.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="n">c_ops</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">,[</span><span class="n">a</span><span class="p">,</span><span class="n">co1_coeff</span><span class="p">]]</span>
<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">c_ops</span><span class="p">,[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">])</span> <span class="c1">#time-dependt Lindblad equation</span>
<span class="n">a_ops</span><span class="o">=</span><span class="p">[[(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()),(</span><span class="s1">&#39;{0}*(w&gt;0)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kappe</span><span class="p">),</span><span class="s1">&#39;exp(1j*t)&#39;</span><span class="p">,</span><span class="s1">&#39;exp(-1j*t)&#39;</span><span class="p">)]]</span>
<span class="n">out2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">brmesolve</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">a_ops</span><span class="p">,</span><span class="n">e_ops</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">])</span> 
<span class="c1">#time-dependt Redfield equation</span></code></pre></div>
<p>除此之外，当含时的参数是非解析的函数或者由实验得到的数据点时，需要将数据点变成函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#anonymous functions</span>
<span class="n">noisy_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">0.05</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
<span class="c1">#generary a random array shape like t,Standard normal distribution</span>
<span class="n">noisy_data</span><span class="o">=</span><span class="n">noisy_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">S</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">Cubic_Spline</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">noisy_data</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[[</span><span class="n">H1</span><span class="p">,</span><span class="n">S</span><span class="p">]]</span></code></pre></div>
<p>含时算符的指数级数表示$\hat{A}=\sum_i\hat{a}e^{r_it}$，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Exponential-series representation
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">es1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">eseries</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="mi">1j</span><span class="p">)</span> <span class="c1">#sigma_x*exp(jt)</span>
<span class="n">es2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">eseries</span><span class="p">([</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="mi">1j</span><span class="p">,</span><span class="o">-</span><span class="mi">1j</span><span class="p">])</span><span class="c1">#sigms_x*exp(jt)+sigma_xexp(-jt)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">evaluate it at time t=2
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">qt</span><span class="o">.</span><span class="n">esval</span><span class="p">(</span><span class="n">es2</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span></code></pre></div>
<h2 id="floquet理论">Floquet理论</h2>

<p>在Lindblad和Bloch-Redfield主方程的标准推导中，所考虑的系统是不显含时时间的。因此，严格地说，这些主方程形式不应盲目地应用于含时哈密顿量的系统。然而，在许多特定的情况下，特别是对于弱驱动的情况，标准主方程仍然适用于许多含时的问题。但更严格的方法是从含时的哈密顿量开始重新推导主方程。Floquet-Markov主方程是这样一种形式的主方程，它在强驱动系统中有着重要的应用。</p>

<p>封闭系统的Floquet计算方法$\psi(t)=\sum<em>{\alpha}c</em>{\alpha}\psi<em>{\alpha}(t)=\sum</em>{\alpha}c<em>{\alpha}e^{-i\epsilon</em>{\alpha}t}\phi<em>{\alpha}(t)$，其中$\psi</em>{\alpha}$表示“Floquet state”，$\phi<em>{\alpha}$表示周期的“Floquet mode”，$\phi</em>{\alpha}(t+T)=\phi<em>{\alpha}(t)$，$\epsilon</em>{\alpha}$表示常数“quasienergy”</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Floquat thoery
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">eps0</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">A</span><span class="o">=</span><span class="mf">2.5</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">H0</span><span class="o">=-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">delta</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">eps0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="n">H1</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span><span class="n">omega</span><span class="p">}</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="s1">&#39;sin(w*t)&#39;</span><span class="p">]]</span>
<span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Calculate the initial Floquet modes Phi_alpha(0) for a driven system with period T.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span> 
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting
</span><span class="s2">the initial Floquet modes Phi_alpha(0)
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">t</span><span class="o">=</span><span class="mf">2.5</span>
<span class="n">f_modes_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes_t</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Decompose the wavefunction `psi` (typically an initial state) in terms of
</span><span class="s2">the Floquet states, :math:`\psi = \sum_</span><span class="se">\a</span><span class="s2">lpha c_</span><span class="se">\a</span><span class="s2">lpha \psi_</span><span class="se">\a</span><span class="s2">lpha(0)`.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">f_coeff</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_state_decomposition</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span><span class="n">psi0</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Evaluate the wavefunction for a time t using the Floquet state
</span><span class="s2">decompositon, given the initial Floquet modes.
</span><span class="s2">f_modes_0:A list of initial Floquet modes
</span><span class="s2">f_energies:The Floquet energies
</span><span class="s2">f_coeff:The coefficients for Floquet decomposition of the initial wavefunction
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
<span class="n">psi_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_wavefunction_t</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span><span class="n">f_coeff</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span></code></pre></div>
<p>耗散系统的Floquet_Markov主方程的计算方法</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">floquet_markov master equation
</span><span class="s2">Note:Currently the qutip.floquet.fmmesolve can only accept a single environment 
</span><span class="s2">coupling operator and spectral-density function.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.0</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">eps0</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">A</span><span class="o">=</span><span class="mf">0.25</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="n">omega</span>
<span class="n">tlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mi">20</span><span class="o">*</span><span class="n">T</span><span class="p">,</span><span class="mi">101</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H0</span><span class="o">=-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">delta</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">eps0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="n">H1</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span><span class="n">omega</span><span class="p">}</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)]]</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">noise power spectrum
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">gamma1</span><span class="o">=</span><span class="mf">0.1</span>
<span class="k">def</span> <span class="nf">noise_spectrum</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">gamma1</span><span class="o">*</span><span class="n">omega</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">find the floquet modes for the time-dependent hamiltonian
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Pre-calculate the Floquet modes for a range of times spanning the floquet
</span><span class="s2">period. Can later be used as a table to look up the floquet modes for any time.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">f_modes_table_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes_table</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span>\
                                       <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="mi">501</span><span class="p">),</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">solve floquet_markov master equation
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">fmmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[],[</span><span class="n">noise_spectrum</span><span class="p">],</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">calaulate expectation values in the computational baisi
</span><span class="s2">enumerate:It is useful for obtaining an indexed list:
</span><span class="s2">    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
</span><span class="s2">    
</span><span class="s2">transform:Input array can be a ``matrix`` defining the transformation,
</span><span class="s2">or a ``list`` of kets that defines the new basis.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">p_ex</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tlist</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tlist</span><span class="p">):</span>
    <span class="n">f_modes_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes_t_lookup</span><span class="p">(</span><span class="n">f_modes_table_t</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
    <span class="n">p_ex</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>\
        <span class="n">output</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">f_modes_t</span><span class="p">,</span><span class="bp">True</span><span class="p">))</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">for reference: calculate the same thing with mesolve
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">output1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma1</span><span class="p">)</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span><span class="n">args</span><span class="p">)</span>
<span class="n">p_ex_ref</span><span class="o">=</span><span class="n">output1</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code></pre></div>
<h2 id="传播子">传播子</h2>

<p>通过对角化Hamilton或Liouvillian的方法得到含时系统的传播子，并计算其时间演化$e^{iHt}\rho e^{-iHt}$。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Assembles the Liouvillian superoperator from a Hamiltonian
</span><span class="s2">and a ``list`` of collapse operators.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">L</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">liouvillian</span><span class="p">(</span><span class="n">H</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Creates an exponential series that describes the time evolution for the
</span><span class="s2">initial density matrix (or state vector) `rho0`, given the Liouvillian
</span><span class="s2">(or Hamiltonian) `L`.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">es</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">ode2es</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">psi0</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">by evaluating it and arbitrary points in time=0.0,1.0
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">es</span><span class="o">.</span><span class="n">value</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span></code></pre></div>
<h2 id="平衡态的计算">平衡态的计算</h2>

<p>在QuTip中，可以以很高的效率寻找Lindblad主方程的平衡态</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">steady state
</span><span class="s2">solving for the steady state solution to the Lindblad master equation 
</span><span class="s2">for a general system
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">N</span><span class="o">=</span><span class="mi">20</span> <span class="c1">#number of basis state to consider</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c1">#initial state</span>
<span class="n">kappa</span><span class="o">=</span><span class="mf">0.1</span> <span class="c1">#couple to oscillator</span>
<span class="c1">#callopse operators</span>
<span class="n">c_op_list</span><span class="o">=</span><span class="p">[]</span>
<span class="n">n_th_a</span><span class="o">=</span><span class="mi">2</span> <span class="c1">#temperature with average of 2 excitations</span>
<span class="n">rate</span><span class="o">=</span><span class="n">kappa</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n_th_a</span><span class="p">)</span>
<span class="k">if</span> <span class="n">rate</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
    <span class="n">c_op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="c1">#decay operators</span>
<span class="n">rate</span><span class="o">=</span><span class="n">kappa</span><span class="o">*</span><span class="n">n_th_a</span>
<span class="k">if</span> <span class="n">rate</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
    <span class="n">c_op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="c1">#excitation oprators</span>
<span class="c1">#find final steady-state solution</span>
<span class="n">final_state</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">steadystate</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">c_op_list</span><span class="p">)</span>
<span class="c1">#find expectation value for partical number in steady state</span>
<span class="n">fexpt</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">final_state</span><span class="p">)</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>QuTip的基本运算</title>
			<link>https://boseliao.github.io/posts/qutip%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</link>
			<pubDate>Fri, 15 May 2020 13:21:41 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qutip%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</guid>
			<description>QuTip (Quantum Toolbox in Python) 是在开源的Python程序语音的框架下，用来模拟量子系统的动力学。其中，定义了一般的量子力学对象，运算算符，以及量子力学方程的求解方法。使用下列代码时，请调用QuTip模块，并使用如下语句
import numpy as np import matplotlib.pyplot as plt import qutip as qt 首先，QuTip 定义了量子对象类(The quantum object class)，可以通过输入命令Qobj(),创建一个空的量子对象。Qobj()类中拥有5个属性，
 Type：ket，bra，operator，superoperator，operator-ket，operator-bra Data：数组 Hermitian：false，ture Dimensions：算符的维度 Shape：数组的形状  具体对象，态的定义 量子态的定义可以通过phi=Qobj([[1],[2],[3]])来得到ket或者bra的态失，也可以通过rho=ket2dm(phi)得到密度矩阵。这里也定义了一些特殊态，Fock state，basis(N,m)或者fock(N,m);相干态，coherence(N,alpha)。具体函数的输入以及参数的使用，可以利用help(basis)查看。
算符的定义 量子算符按照是否可观测可分为Hermitian算符与non-Hermitian算符，可以定义
r=np.array([[1,2],[3,4]]) Qobj(r) 其中也定义了一些常用的算符：
   operator command     Commutator commutator(A,B,kind)   sigma-X sigmax()   Lowing operator destroy(N)    等等。。。
超算符 在Liouville空间中，算符在处理时被视为向量，可以通过
vec_rho=operator_to_vector(rho) rho=vector_to_operator(vec_rho) 超算符
X=sigmax() S=spre(X) #I tensor X S1=spost(X) # X tensor I S2=spre(X)*spost(X.</description>
			<content type="html"><![CDATA[

<p>QuTip (Quantum Toolbox in Python) 是在开源的Python程序语音的框架下，用来模拟量子系统的动力学。其中，定义了一般的量子力学对象，运算算符，以及量子力学方程的求解方法。使用下列代码时，请调用QuTip模块，并使用如下语句</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span></code></pre></div>
<hr />

<p>首先，QuTip 定义了量子对象类(The quantum object class)，可以通过输入命令<code>Qobj()</code>,创建一个空的量子对象。<code>Qobj()</code>类中拥有5个属性，</p>

<ul>
<li>Type：ket，bra，operator，superoperator，operator-ket，operator-bra</li>
<li>Data：数组</li>
<li>Hermitian：false，ture</li>
<li>Dimensions：算符的维度</li>
<li>Shape：数组的形状</li>
</ul>

<h2 id="具体对象-态的定义">具体对象，态的定义</h2>

<p>量子态的定义可以通过<code>phi=Qobj([[1],[2],[3]])</code>来得到ket或者bra的态失，也可以通过<code>rho=ket2dm(phi)</code>得到密度矩阵。这里也定义了一些特殊态，Fock state，<code>basis(N,m)</code>或者<code>fock(N,m)</code>;相干态，<code>coherence(N,alpha)</code>。具体函数的输入以及参数的使用，可以利用<code>help(basis)</code>查看。</p>

<h2 id="算符的定义">算符的定义</h2>

<p>量子算符按照是否可观测可分为Hermitian算符与non-Hermitian算符，可以定义</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">r</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">Qobj</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code></pre></div>
<p>其中也定义了一些常用的算符：</p>

<table>
<thead>
<tr>
<th align="center">operator</th>
<th align="center">command</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Commutator</td>
<td align="center">commutator(A,B,kind)</td>
</tr>

<tr>
<td align="center">sigma-X</td>
<td align="center">sigmax()</td>
</tr>

<tr>
<td align="center">Lowing operator</td>
<td align="center">destroy(N)</td>
</tr>
</tbody>
</table>

<p>等等。。。</p>

<h2 id="超算符">超算符</h2>

<p>在Liouville空间中，算符在处理时被视为向量，可以通过</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">vec_rho</span><span class="o">=</span><span class="n">operator_to_vector</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="n">rho</span><span class="o">=</span><span class="n">vector_to_operator</span><span class="p">(</span><span class="n">vec_rho</span><span class="p">)</span></code></pre></div>
<p>超算符</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">X</span><span class="o">=</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">S</span><span class="o">=</span><span class="n">spre</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1">#I tensor X</span>
<span class="n">S1</span><span class="o">=</span><span class="n">spost</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c1"># X tensor I</span>
<span class="n">S2</span><span class="o">=</span><span class="n">spre</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">spost</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span></code></pre></div>
<p>其中S2也可以表达成</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">S2</span><span class="o">=</span><span class="n">to_super</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></code></pre></div>
<p>超算符可以表达成Kraus和形式</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">to_kraus</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span></code></pre></div>
<p>超算符正定性的验证</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">S</span><span class="o">.</span><span class="n">iscp</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">istp</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">iscptp</span></code></pre></div>
<h2 id="算符函数">算符函数</h2>

<p>QuTip也提供了一些算符的函数：</p>

<table>
<thead>
<tr>
<th>Function</th>
<th>Command</th>
<th>Desciption</th>
</tr>
</thead>

<tbody>
<tr>
<td>Conjugate</td>
<td>Q.conj()</td>
<td>Conjugate of quantum operator,Q represent Qobj</td>
</tr>

<tr>
<td>Dagger</td>
<td>Q.dag()</td>
<td></td>
</tr>

<tr>
<td>Diagonal</td>
<td>Q.diag()</td>
<td></td>
</tr>

<tr>
<td>Eigenstate</td>
<td>Q.eigenstates()</td>
<td>return eigenvector and eigenvalue</td>
</tr>

<tr>
<td>Trace</td>
<td>Q.tr()</td>
<td></td>
</tr>

<tr>
<td>Partial trace</td>
<td>Q.ptrace()</td>
<td></td>
</tr>

<tr>
<td>Transpose</td>
<td>Q.trans()</td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="薛定谔方程">薛定谔方程</h2>

<p>在close量子系统中，量子态的时间演化可以通过薛定谔方程求解。<u>以下代码用qt代表qutip</u></p>

<p>$ih\frac{\partial}{\partial t}\psi (t)=H\psi (t)$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">H</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.1</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="n">result</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()])</span></code></pre></div>
<p>H表示哈密顿量，psi0表示处于初态，time表示数值计算的时间序列，最后一个参数<code>[qt.sigmaz()]</code>表示输出该算符的平均值。</p>

<p>类似于<code>Qobj()</code>，求解方程得到的输出result属于<code>qutip.solver.Result</code>定义的类。他也具有一些重要的属性，</p>

<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>result.times</td>
<td>List/array of times at which simulation data is calculated.</td>
</tr>

<tr>
<td>result.expect</td>
<td>List/array of expectation values</td>
</tr>

<tr>
<td>result.states</td>
<td>List/array of state vectors/density matrices calculated at times</td>
</tr>
</tbody>
</table>

<p>将结果可视化，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">times</span><span class="p">,</span><span class="n">result</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Times&#39;</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;expactation value&#39;</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s2">&#34;sigma_z&#34;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p>含时量子系统的表示以及求解，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">H0</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.1</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="n">H1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="n">A</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
    <span class="n">sig</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">sig</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>
<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="mf">9.0</span><span class="p">,</span><span class="s1">&#39;sigma&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">}</span>
<span class="n">result</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()],</span><span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span></code></pre></div>
<p>其中H0是不含时部分，H1的含时部分用函数描述，即<code>H=H0+f(t)*H1</code>。对应的任一含时算符都可以这样表示。<code>A</code>与<code>sig</code>表示模拟计算中可变的参数。</p>

<h2 id="lindblad主方程">Lindblad主方程</h2>

<p>量子开放系统的动力学常常需要利用主方程描述，其中最重要的形式是Lindblad形式。对于Linblad主方程的求解，其中$C_n$表示跃迁算符(collapse operation)</p>

<p>$\dot{\rho}=-\frac{i}{h}\left[H,\rho \right]+\sum_n\frac{1}{2}\left[2C_n\rho(t)C_n^{\dagger}-\rho(t)C_n^{\dagger}C_n-C_n^{\dagger}C_n\rho(t) \right]$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Lindblad equation(use mesolve())
</span><span class="s2">H:Hamiltonian
</span><span class="s2">psi0:initial state
</span><span class="s2">time:time list
</span><span class="s2">c_ops:a list of collapse operation
</span><span class="s2">return the expect value of operator
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">time2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">result2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time2</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>\
                                 <span class="p">,</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">()])</span></code></pre></div>
<p>其中，<code>mesolve</code>函数中第四个参数<code>c_ops</code>表示Lindblad主方程中的跃迁算符。利用蒙特卡洛方法求解Lindblad主方程</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">monte carlo
</span><span class="s2">advantage:keep state vector rather density matrix
</span><span class="s2">error=1/ntraj
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">result3</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">time2</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>\
                                 <span class="p">,</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">()],</span><span class="n">ntraj</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span></code></pre></div>
<p>对于求解大量粒子的系统，蒙特卡洛方法在计算时间以及内存的使用上具有更大的优势，其误差正比于<code>1/ntraj</code>。</p>

<p>这里介绍的求解Lindblad主方程的两种方法都可以用来求解含时的哈密顿量，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">ustate</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">excited</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ground</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">N</span><span class="o">=</span><span class="mi">2</span> <span class="c1">#dimension of cavity</span>
<span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span> <span class="c1">#define time vector</span>
<span class="n">sigma_ge</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">ground</span><span class="o">*</span><span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="c1">#|g&gt;&lt;e|</span>
<span class="n">sigma_ue</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">ustate</span><span class="o">*</span><span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="c1">#|u&gt;&lt;e|</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">ada</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">C_ops</span><span class="o">=</span><span class="p">[]</span> <span class="c1">#build a collapse operators</span>
<span class="n">Kappa</span><span class="o">=</span><span class="mf">1.5</span> <span class="c1">#Cavity decay rate</span>
<span class="n">C_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Kappa</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="n">gamma</span><span class="o">=</span><span class="mf">6.0</span> <span class="c1">#Atomic decay rate</span>
<span class="n">C_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">*</span><span class="n">sigma_ue</span><span class="p">)</span> <span class="c1">#5/9 e--&gt;u</span>
<span class="n">C_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span><span class="o">*</span><span class="n">sigma_ge</span><span class="p">)</span> <span class="c1">#4/9 e--&gt;g</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">ustate</span><span class="p">)</span> <span class="c1">#define initial state</span>
<span class="n">state_GG</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">ground</span><span class="p">)</span> <span class="c1">#define state onto which to project</span>
<span class="n">sigma_GG</span><span class="o">=</span><span class="n">state_GG</span><span class="o">*</span><span class="n">state_GG</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">state_UU</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">ustate</span><span class="p">)</span>
<span class="n">sigma_UU</span><span class="o">=</span><span class="n">state_UU</span><span class="o">*</span><span class="n">state_UU</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">g</span><span class="o">=</span><span class="mi">5</span> <span class="c1">#couple strength</span>
<span class="n">H0</span><span class="o">=-</span><span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">sigma_ge</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sigma_ue</span><span class="p">)</span> <span class="c1">#time-independent term</span>
<span class="n">H1</span><span class="o">=</span><span class="n">sigma_ue</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">+</span><span class="n">sigma_ue</span>
<span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="mf">5.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>
<span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">C_ops</span><span class="p">,[</span><span class="n">ada</span><span class="p">,</span><span class="n">sigma_UU</span><span class="p">,</span><span class="n">sigma_GG</span><span class="p">])</span></code></pre></div>
<h2 id="bloch-redfield方程">Bloch-Redfield方程</h2>

<p>Bloch-Redfield方程是主方程的矩阵元表现形式，对其求解可以先求出Redfield张量，再求解方程</p>

<p>$\dot{\rho}<em>{ab}(t)=-i\omega</em>{ab}\rho<em>{ab}\sum</em>{cd}R<em>{abcd}\rho</em>{cd}(t)$</p>

<p>$R<em>{abcd}=-\frac{1}{2}\sum</em>{\alpha\beta}\left[\delta_{bd}\sum<em>nA^{\alpha}</em>{an}A^{\beta}<em>{nc}S</em>{\alpha\beta}(\omega<em>{cn})-A^{\alpha}</em>{ac}A^{\beta}<em>{db}S</em>{\alpha\beta}(\omega<em>{ca})\right.$$\left.+\delta</em>{ac}\sum<em>nA^{\alpha}</em>{dn}A^{\beta}<em>{nb}S</em>{\alpha\beta}(\omega<em>{dn})+A^{\alpha}</em>{ac}A^{\beta}<em>{db}S</em>{\alpha\beta}(\omega_{db}) \right]$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Bloch redfield
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">eps0</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">gamma1</span><span class="o">=</span><span class="mf">0.5</span>
<span class="n">H</span><span class="o">=-</span><span class="n">delta</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">-</span><span class="n">eps0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">ohmic_spectrum</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">w</span><span class="o">==</span><span class="mf">0.0</span> <span class="p">:</span>
        <span class="k">return</span> <span class="n">gamma1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gamma1</span><span class="o">/</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">R</span><span class="p">,</span><span class="n">ekets</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">bloch_redfield</span><span class="o">.</span><span class="n">bloch_redfield_tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,[[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">ohmic_spectrum</span><span class="p">]])</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">R:Bloch-Redfiled tensor
</span><span class="s2">ekets:eigenket of H
</span><span class="s2">ohmic_spectrum:2.0*Gamma(w)
</span><span class="s2">sigmax():the operator coupled with environment
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">tlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">rand_ket</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">e_ops</span><span class="o">=</span><span class="p">[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()]</span>
<span class="n">expt_list</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">bloch_redfield_solve</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">ekets</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,</span><span class="n">e_ops</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Bloch sphere
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">sphere</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Bloch</span><span class="p">()</span> <span class="c1">#create a Bloch sphere</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">add_points</span><span class="p">([</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span> <span class="c1">#add 3d point&#39; position</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">vector_color</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">add_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delta</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">eps0</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">eps0</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1">#add vector</span>
<span class="n">sphere</span><span class="o">.</span><span class="n">make_sphere</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p>最后在布洛赫球上对解进行可视化。类似于Lindblad方程，也可以直接求解</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">brmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,</span><span class="n">a_ops</span><span class="o">=</span><span class="p">[[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">ohmic_spectrum</span><span class="p">]]</span>\
                                         <span class="p">,</span><span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">)</span></code></pre></div>
<p>值得注意的是第一种方法的解<code>expt_list</code>并不属于<code>qutip.solver.Result</code>类，只是单纯存储着数组（算符的平均值），而第二种解是完全类似与Lindblad方程解的结构。</p>
]]></content>
		</item>
		
		<item>
			<title>QuTip的安装与配置</title>
			<link>https://boseliao.github.io/posts/qutip%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
			<pubDate>Wed, 13 May 2020 10:17:14 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qutip%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
			<description>Qutip(Quantum Toolbox in Python)是用于研究量子系统的有力工具，这是python下的一个模块，我们需要下载，安装他。
 推荐使用conda进行python环境的管理，对于python环境的基本配置可在参考书目1，以及对于Python语句的学习使用参考书目2。QuTip的安装参考指导手册。需要注意的是，在安装完miniconda或者Anaconda之后，需要更新conda使用命令。
conda update conda  conda的配置   首先使用conda list查看安装的包以及python版本，特别的，模块QuTip的安装依赖以下的包numpy，scipy，cython，pytest并且python的版本必须在3.0以上，需要确认以上包已经被安装在conda环境中。如果没有上述包，则使用如下语句进行包的安装。类似的，Python的IDE也可以用如下命令选择安装skyder。
conda install package_name 添加conda的频道并更新
conda config --append channels conda-forge conda config --add channels conda-forge conda update  创建配置python3环境   如果发现Python不是3.0以上版本，可以利用conda创建新的python3环境，并在python3环境中重新配置QuTip。首先使用命令
conda env list 查看环境列表，在前面带有*表示当前环境，一般处于base环境中。接下来我们创建python3环境，
conda create -n python3 python=3 这里我们创建了名称为python3，并且安装了python3最新版本的环境。使用命令
source activate python3 可以激活环境python3。首先，在该环境下查看是否安装了python3以上的版本使用python --version，如果没有使用命令
conda install python 就可以安装Python3版本。并在环境python3中，重复二步骤检查QuTip的依赖包。
依旧在python3环境中，使用conda install qutip安装qutip，如果无法搜索到则可以到QuTip官网下载安装包，在python3环境中使用pip安装
pip install QuTip.* 最后QuTip的测试代码，如果能显示无误，那么就安装成功了。
import qutip.testing as qt qt.run()  Python物理学高效计算 [return] Python物理建模初学者指南 [return]   </description>
			<content type="html"><![CDATA[<p>Qutip(Quantum Toolbox in Python)是用于研究量子系统的有力工具，这是python下的一个模块，我们需要下载，安装他。</p>

<blockquote>
<p>推荐使用conda进行python环境的管理，对于python环境的基本配置可在参考书目<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>，以及对于Python语句的学习使用参考书目<sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup>。QuTip的安装参考<a href="http://qutip.org/docs/latest/installation.html">指导手册</a>。需要注意的是，在安装完miniconda或者Anaconda之后，需要更新conda使用命令。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">conda update conda</code></pre></div></blockquote>

<ul>
<li>conda的配置</li>
</ul>

<blockquote>
<p>首先使用<code>conda list</code>查看安装的包以及python版本，特别的，模块QuTip的安装依赖以下的包<code>numpy</code>，<code>scipy</code>，<code>cython</code>，<code>pytest</code>并且python的版本必须在3.0以上，需要确认以上包已经被安装在conda环境中。如果没有上述包，则使用如下语句进行包的安装。类似的，Python的IDE也可以用如下命令选择安装skyder。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">conda install package_name</code></pre></div>
<p>添加conda的频道并更新</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">conda config --append channels conda-forge
conda config --add channels conda-forge
conda update</code></pre></div></blockquote>

<ul>
<li>创建配置python3环境</li>
</ul>

<blockquote>
<p>如果发现Python不是3.0以上版本，可以利用conda创建新的python3环境，并在python3环境中重新配置QuTip。首先使用命令</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">conda env list</code></pre></div>
<p>查看环境列表，在前面带有<code>*</code>表示当前环境，一般处于<code>base</code>环境中。接下来我们创建python3环境，</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">conda create -n python3 <span class="nv">python</span><span class="o">=</span><span class="m">3</span></code></pre></div>
<p>这里我们创建了名称为<code>python3</code>，并且安装了python3最新版本的环境。使用命令</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">source</span> activate python3</code></pre></div>
<p>可以激活环境python3。首先，在该环境下查看是否安装了python3以上的版本使用<code>python --version</code>，如果没有使用命令</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">conda install python</code></pre></div>
<p>就可以安装Python3版本。并在环境python3中，重复二步骤检查QuTip的依赖包。</p>

<p>依旧在python3环境中，使用<code>conda install qutip</code>安装qutip，如果无法搜索到则可以到<a href="http://qutip.org/download.html">QuTip官网</a>下载安装包，在python3环境中使用pip安装</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">pip install QuTip.*</code></pre></div>
<p>最后QuTip的测试代码，如果能显示无误，那么就安装成功了。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">qutip.testing</span> <span class="kn">as</span> <span class="nn">qt</span>
<span class="n">qt</span><span class="o">.</span><span class="n">run</span><span class="p">()</span></code></pre></div></blockquote>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">Python物理学高效计算
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">Python物理建模初学者指南
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
</ol>
</div>
]]></content>
		</item>
		
		<item>
			<title>MakeDown初识</title>
			<link>https://boseliao.github.io/posts/makedawn%E5%88%9D%E8%AF%86/</link>
			<pubDate>Mon, 11 May 2020 17:49:12 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/makedawn%E5%88%9D%E8%AF%86/</guid>
			<description>标题的设置  使用“#”进行标题设置，“#+空格”表示一级标题，“##+空格”表示二级标题…以此类推； 在标题下方画横短线，“===”表示一级标题，“—”表示二级标题。  段落  使用空行来分行 斜体*txt*，粗体**txt**，下划线&amp;lt;u&amp;gt;txt&amp;lt;/u&amp;gt;  区块  段落区块使用&amp;gt;
 使用&amp;gt;&amp;gt;可以嵌套
  代码区块，若是在段落中可以用反引号将代码块包含，整段的代码可以使用4个空格或者一个制表符（Tab键）或是三个反引号输入语言类型，例如
program main implicit none int x x=1 write(*,*) end program 表格与图片  表格     表头 表头 表头     单元格 单元格 单元格   单元格 单元格 单元格    代码
| 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 |  图片  代码</description>
			<content type="html"><![CDATA[

<h2 id="标题的设置">标题的设置</h2>

<ol>
<li>使用“#”进行标题设置，“#+空格”表示一级标题，“##+空格”表示二级标题…以此类推；</li>
<li>在标题下方画横短线，“===”表示一级标题，“—”表示二级标题。</li>
</ol>

<h2 id="段落">段落</h2>

<ol>
<li>使用空行来分行</li>
<li><em>斜体</em><code>*txt*</code>，<strong>粗体</strong><code>**txt**</code>，<u>下划线</u><code>&lt;u&gt;txt&lt;/u&gt;</code></li>
</ol>

<h2 id="区块">区块</h2>

<blockquote>
<p>段落区块使用<code>&gt;</code></p>

<blockquote>
<p>使用<code>&gt;&gt;</code>可以嵌套</p>
</blockquote>
</blockquote>

<p>代码区块，若是在段落中可以用反引号将代码块包含，整段的代码可以使用4个空格或者一个制表符（Tab键）或是三个反引号输入语言类型，例如</p>
<div class="highlight"><pre class="chroma"><code class="language-fortran" data-lang="fortran"><span class="k">program </span><span class="n">main</span>
<span class="k">implicit none
</span><span class="k"></span><span class="nb">int </span><span class="n">x</span>
<span class="n">x</span><span class="o">=</span><span class="mi">1</span>
<span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span>
<span class="k">end program</span></code></pre></div>
<h2 id="表格与图片">表格与图片</h2>

<ul>
<li>表格</li>
</ul>

<table>
<thead>
<tr>
<th align="center">表头</th>
<th align="center">表头</th>
<th align="center">表头</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">单元格</td>
<td align="center">单元格</td>
<td align="center">单元格</td>
</tr>

<tr>
<td align="center">单元格</td>
<td align="center">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody>
</table>

<p>代码</p>
<div class="highlight"><pre class="chroma"><code class="language-makedown" data-lang="makedown">|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |</code></pre></div>
<ul>
<li>图片</li>
</ul>

<p>代码</p>
<div class="highlight"><pre class="chroma"><code class="language-makedown" data-lang="makedown">![Boseliao 图标](图片网址 &#34;Boseliao&#34;)</code></pre></div>
<ul>
<li>链接

<ul>
<li>网站外链接，使用代码<code>[链接名称](链接地址)</code>或<code>&lt;链接地址&gt;</code>，这是我的网址<a href="https://boseliao.github.io">Boseliao&rsquo;Blog</a></li>
<li>多次链接</li>
</ul></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-makedown" data-lang="makedown">[链接文字][name]

[name]: link &#34;Title&#34;</code></pre></div>
<ul>
<li>网站内链接<code>[显示的内容](#标题标号-标题文本)</code><a href="#表格与图片">跳转到表格与图片</a></li>
</ul>

<h2 id="数学公式">数学公式</h2>

<p>可以使用<code>$$</code>包裹latex格式的数学代码，需要浏览器安装MathJax插件
$$
\hat{\sigma}_z
$$</p>

<h2 id="流程图">流程图</h2>

<ul>
<li>使用mermaid画流程图，先画三个反引号，再输入流程类型mermaid，横向</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-mermaid" data-lang="mermaid">graph LR
A[方形]--&gt;B(圆角)
	B--&gt;C{条件}
	C --&gt;|a=1| D[结果1]
	C --&gt;|a=2| E[结果2]
	F[横向流程图]</code></pre></div>
<p>代码</p>
<div class="highlight"><pre class="chroma"><code class="language-makedown" data-lang="makedown">graph LR
A[方形]--&gt;B(圆角)
	B--&gt;C{条件}
	C --&gt;|a=1| D[结果1]
	C --&gt;|a=2| E[结果2]
	F[横向流程图]</code></pre></div>
<ul>
<li>竖向流程</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-mermaid" data-lang="mermaid">graph TD
A[方形] --&gt; B(圆角)
    B --&gt; C{条件a}
    C --&gt; |a=1| D[结果1]
    C --&gt; |a=2| E[结果2]
    F[竖向流程图]</code></pre></div>
<ul>
<li>标准流程图<code>flow</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-flow" data-lang="flow">st=&gt;start: 开始框
op=&gt;operation: 处理框
cond=&gt;condition: 判断框(是或否?)
sub1=&gt;subroutine: 子流程
io=&gt;inputoutput: 输入输出框
e=&gt;end: 结束框
st-&gt;op-&gt;cond
cond(yes)-&gt;io-&gt;e
cond(no)-&gt;sub1(right)-&gt;op</code></pre></div>
<ul>
<li>标准流程图（横向）<code>flow</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-flow" data-lang="flow">st=&gt;start: 开始框
op=&gt;operation: 处理框
cond=&gt;condition: 判断框(是或否?)
sub1=&gt;subroutine: 子流程
io=&gt;inputoutput: 输入输出框
e=&gt;end: 结束框
st(right)-&gt;op(right)-&gt;cond
cond(yes)-&gt;io(bottom)-&gt;e
cond(no)-&gt;sub1(right)-&gt;op</code></pre></div>
<ul>
<li>UML时序图源<code>sequence</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sequence" data-lang="sequence">对象A-&gt;对象B: 对象B你好吗?（请求）
Note right of 对象B: 对象B的描述
Note left of 对象A: 对象A的描述(提示)
对象B--&gt;对象A: 我很好(响应)
对象A-&gt;对象B: 你真的好吗？</code></pre></div>
<ul>
<li>UML时序图(复杂)<code>sequence</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sequence" data-lang="sequence">Title: 标题：复杂使用
对象A-&gt;对象B: 对象B你好吗?（请求）
Note right of 对象B: 对象B的描述
Note left of 对象A: 对象A的描述(提示)
对象B--&gt;对象A: 我很好(响应)
对象B-&gt;小三: 你好吗
小三--&gt;&gt;对象A: 对象B找我了
对象A-&gt;对象B: 你真的好吗？
Note over 小三,对象B: 我们是朋友
participant C
Note right of C: 没人陪我玩</code></pre></div>
<ul>
<li>UML标准时序图<code>mermaid</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-mermaid" data-lang="mermaid">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头
  sequenceDiagram
    participant 张三
    participant 李四
    张三-&gt;王五: 王五你好吗？
    loop 健康检查
        王五-&gt;王五: 与疾病战斗
    end
    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...
    李四--&gt;&gt;张三: 很好!
    王五-&gt;李四: 你怎么样?
    李四--&gt;王五: 很好!</code></pre></div>
<ul>
<li>甘特图<code>mermaid</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-mermaid" data-lang="mermaid">%% 语法示例
        gantt
        dateFormat  YYYY-MM-DD
        title 软件开发甘特图
        section 设计
        需求                      :done,    des1, 2014-01-06,2014-01-08
        原型                      :active,  des2, 2014-01-09, 3d
        UI设计                     :         des3, after des2, 5d
    未来任务                     :         des4, after des3, 5d
        section 开发
        学习准备理解需求                      :crit, done, 2014-01-06,24h
        设计框架                             :crit, done, after des2, 2d
        开发                                 :crit, active, 3d
        未来任务                              :crit, 5d
        耍                                   :2d
        section 测试
        功能测试                              :active, a1, after des3, 3d
        压力测试                               :after a1  , 20h
        测试报告                               : 48h</code></pre></div>
<p>以上使用typora编译，参考资料<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟编程</a></p>
]]></content>
		</item>
		
		<item>
			<title>First_post</title>
			<link>https://boseliao.github.io/posts/first_posts/</link>
			<pubDate>Thu, 02 Jan 2020 14:51:20 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/first_posts/</guid>
			<description>I am BoseLiao</description>
			<content type="html"><![CDATA[<p>I am BoseLiao</p>
]]></content>
		</item>
		
	</channel>
</rss>
