<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on BoseLiao&#39;s Blog</title>
		<link>https://boseliao.github.io/posts/</link>
		<description>Recent content in Posts on BoseLiao&#39;s Blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Wed, 17 Jun 2020 12:50:24 +0800</lastBuildDate>
		<atom:link href="https://boseliao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>QC:shor_orderfounding</title>
			<link>https://boseliao.github.io/posts/qcshor_orderfounding/</link>
			<pubDate>Wed, 17 Jun 2020 12:50:24 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qcshor_orderfounding/</guid>
			<description>算法原理：
设一大数N，可以分解成N=n1*n2，shor算法概述：
 随机取一正整数y，要求y&amp;lt;N，且与N互质，利用order-founding算法求r=ord(y,N)，r是使得 $$ y^r(mod)N=1 $$ 的最小整数。等价的可以得到 $$ \begin{array}{1c} y^r=kN+1\newline y^{r+1}=kNy+y\newline y^{r+1}(mod)N=y(mod)N\newline y^{r+x}(mod)N=y^x(mod)N \end{array} $$ 即函数f(t)的周期为r $$ f(t)=y^t(mod)N $$
 若得到的周期r为奇数或者r是偶数但 $$ y^{r/2}(mod)N=-1 $$ 则重新取y值，并重复第一个步骤。
 r是偶数，且 $$ y^{r/2}(mod)N\neq-1 $$ 取 $$ x(mod)N=y^{r/2},\quad x^2(mod)N=1,\quad (x+1)(x-1)=tN=t*n1*n2 $$ 分别对他们取最大公约数，可以得到n1，n2 $$ n1=gcd(x+1,N),\quad n2=gcd(x-1,N) $$
 Euclid&amp;rsquo;s algorithm计算gcd(x,N),N&amp;gt;x，
  $$ r=N(mod)x,\quad r=0,z=x $$
$$ r\neq 0,\quad z=gcd(N,x)=gcd(x,r)=gcd(r,r_1)=\cdots=gcd(r_m,0)=r_m $$
order founding 利用量子傅里叶算法以及量子相位估计算法实现r=ord(y,N)。
需要两组寄存器
 寄存器1，包含K个量子比特，存储数字Q $$ Q=2^K,\quad N^2&amp;lt;Q&amp;lt;2N^2 $$
 寄存器2，包含n个量子比特，存储数字N $$ N=2^n $$</description>
			<content type="html"><![CDATA[

<p>算法原理：</p>

<p>设一大数N，可以分解成N=n1*n2，shor算法概述：</p>

<ol>
<li><p>随机取一正整数y，要求y&lt;N，且与N互质，利用order-founding算法求r=ord(y,N)，r是使得
$$
y^r(mod)N=1
$$
的最小整数。等价的可以得到
$$
\begin{array}{1c}
y^r=kN+1\newline
y^{r+1}=kNy+y\newline
y^{r+1}(mod)N=y(mod)N\newline
y^{r+x}(mod)N=y^x(mod)N
\end{array}
$$
即函数f(t)的周期为r
$$
f(t)=y^t(mod)N
$$</p></li>

<li><p>若得到的周期r为奇数或者r是偶数但
$$
y^{r/2}(mod)N=-1
$$
则重新取y值，并重复第一个步骤。</p></li>

<li><p>r是偶数，且
$$
y^{r/2}(mod)N\neq-1
$$
取
$$
x(mod)N=y^{r/2},\quad x^2(mod)N=1,\quad (x+1)(x-1)=tN=t*n1*n2
$$
分别对他们取最大公约数，可以得到n1，n2
$$
n1=gcd(x+1,N),\quad n2=gcd(x-1,N)
$$</p></li>

<li><p>Euclid&rsquo;s algorithm计算gcd(x,N),N&gt;x，</p></li>
</ol>

<p>$$
r=N(mod)x,\quad r=0,z=x
$$</p>

<p>$$
r\neq 0,\quad z=gcd(N,x)=gcd(x,r)=gcd(r,r_1)=\cdots=gcd(r_m,0)=r_m
$$</p>

<h2 id="order-founding">order founding</h2>

<p>利用量子傅里叶算法以及量子相位估计算法实现r=ord(y,N)。</p>

<p>需要两组寄存器</p>

<ul>
<li><p>寄存器1，包含K个量子比特，存储数字Q
$$
Q=2^K,\quad N^2&lt;Q&lt;2N^2
$$</p></li>

<li><p>寄存器2，包含n个量子比特，存储数字N
$$
N=2^n
$$</p></li>
</ul>

<p>所有寄存器1的初态设为|0&gt;，寄存器2的初态设为|1&gt;，将寄存器1经过<code>Hadmard</code>门
$$
(H^{\otimes K}|0\rangle)|1\rangle=\frac{1}{\sqrt{Q}}\sum_{q=0}^{Q-1}|q\rangle|1\rangle
$$
在经过一个控制电路，
$$
U_y(q)\frac{1}{\sqrt{Q}}\sum_{q=0}^{Q-1}|q\rangle|1\rangle=\frac{1}{\sqrt{Q}}\sum_{q=0}^{Q-1}|q\rangle|y^q(mod)N\rangle
$$</p>

<p>利用Modular exponentiation算法制备以上态，设
$$
U|x\rangle=|xy(mod)N\rangle,\quad U^2|x\rangle=|xy^2(mod)N\rangle
$$
所以
$$
U_y(q)|q\rangle|1\rangle=|q\rangle|y^q(mod)N\rangle=|q\rangle|y^{q_{K-1}2^{K-1}\cdots q_02^0}(mod)N\rangle=|q\rangle U^{q_{K-1}2^{K-1}}\cdots U^{q_02^0}|1\rangle
$$
其中
$$
U^{2^j}=U^{2^{j-1}}U^{2^{j-1}}
$$
测量寄存器2中的量子比特，假设得到f(q0)，Q=mr，则量子态变成
$$
\frac{1}{\sqrt{m}}\sum_{j=0}^{m-1}|jr+q_0\rangle |f(q_0)\rangle
$$
目前寄存器1的量子比特处于叠加态，直接测量还无法方便的得到周期，这里对其做傅里叶变化，
$$
\frac{1}{\sqrt{m}}\sum_{j=0}^{m-1}|jr+q_0\rangle\to\frac{1}{\sqrt{mQ}}\sum_{k=0}^{Q-1}\sum_{j=0}^{m-1}e^{2\pi i\frac{(jr+q_0)k}{Q}}|k\rangle=\frac{1}{\sqrt{mQ}}\sum_{k=0}^{Q-1}\left(\sum_{j=0}^{m-1}e^{2\pi i\frac{jk}{m}}\right)e^{2\pi i\frac{q_0k}{Q}}|k\rangle
$$
对于内部的求和
$$
\sum_{j=0}^{m-1}e^{2\pi i\frac{jk}{m}}=m\delta_{k,mk\prime}
$$
寄存器1中的量子态
$$
\frac{m}{\sqrt{mQ}}\sum_{k=0}^{Q-1}e^{2\pi i\frac{q_0k}{Q}}|k\rangle=\frac{1}{\sqrt{r}}\sum_{k\prime=0}^{r-1}e^{2\pi i\frac{q_0k\prime}{r}}|mk\prime\rangle
$$
测量得到
$$
C=mk\prime=\frac{Q}{r}k\prime,\quad \frac{C}{Q}=\frac{k\prime}{r}
$$
当gcd(k\prime,r)=1时，可以唯一确定周期r，测量得到gcd(k\prime,r)=1的概率大于1/log[r]。最后，令
$$
x=y^{r/2}\pm 1
$$
并计算，
$$
z=gcd(N,x)
$$</p>
]]></content>
		</item>
		
		<item>
			<title>QC:quantum_phase_estimation</title>
			<link>https://boseliao.github.io/posts/qcquantum_phase_estimation/</link>
			<pubDate>Sat, 13 Jun 2020 18:16:09 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qcquantum_phase_estimation/</guid>
			<description>quantum phase estimation(QPE) 量子相位估计算法应用了量子傅里叶逆变换，同时作为一个实用的基础量子算法，又被应用在Shor&amp;rsquo;s Algorithm（质因式分解算法），和HHL algorithm（经常用于各种量子机器学习的最优化算法）等等算法中。
假设有一个幺正算符U，具有本征态|u&amp;gt;，以及对应的本征值为e^(i\phi),(0&amp;lt;\phi的量子比特，你的选取将会影响得到\phi的精度以及得到正确本征值的概率。二，第二组寄存器需要足够量子比特存储态|u&amp;gt;。
由图可知，第一组寄存器的量子比特经过一个Hadmard门和C-U^{2^j}门 $$ |0\rangle\cdots|0\rangle|u\rangle\to Hadamard\to\frac{1}{\sqrt{2^n}}\left(|0\rangle+|1\rangle \right)\cdots\left(|0\rangle+|1\rangle \right)|u\rangle $$
$$ \to C-U^{2^j}\to\frac{1}{\sqrt{2^n}}\left(|0\rangle+e^{i2^{n-1}\phi}|1\rangle \right)\cdots\left(|0\rangle+e^{i\phi}|1\rangle \right)|u\rangle=\frac{1}{\sqrt{2^n}}\sum_{y=0}^{2^n-1}e^{i\phi y}|y\rangle |u\rangle $$
这里输出第一组寄存器中的\phi依赖于测量态的概率，但我们测量到的是态而非概率幅度，利用傅里叶变换可以将概率幅度存储的相位存储到量子态中。量子傅里叶逆变换为 $$ QFT^{-1}|y\rangle=\frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^{n}-1}\exp(-2\pi i\frac{xy}{2^n})|x\rangle $$ 将\phi写成 $$ \phi=2\pi\left(\frac{a}{2^n}+\delta \right),\quad a=a_{n-1}\cdots a_0,0&amp;lt;\delta|u&amp;gt;，可以得到本征值 $$ \phi=\frac{2\pi a}{2^n} $$ 当\delta不等于0时，则测到态|a&amp;gt;|u&amp;gt;的概率幅 $$ C_a=\frac{1}{2^n}\sum_{y=0}^{2^n-1}e^{2\pi i\delta y}&amp;gt;\frac{2}{\pi} $$
import numpy as np import matplotlib.pyplot as plt import qutip as qt from qutip.qip.circuit import QubitCircuit, Gate from qutip.qip import gates def user_gate1(): &amp;#34;&amp;#34;&amp;#34; define C-U:control-qubit=0,u=1;conrol-qubit=1,u=[[1.,0.],[0.,-1.]] &amp;#34;&amp;#34;&amp;#34; mat_control0=qt.</description>
			<content type="html"><![CDATA[<p>quantum phase estimation(QPE) 量子相位估计算法应用了量子傅里叶逆变换，同时作为一个实用的基础量子算法，又被应用在Shor&rsquo;s Algorithm（质因式分解算法），和HHL algorithm（经常用于各种量子机器学习的最优化算法）等等算法中。</p>

<p>假设有一个幺正算符U，具有本征态|u&gt;，以及对应的本征值为e^(i\phi),(0&lt;\phi<2\pi)。
$$
U|u\rangle=e^{i\phi}|u\rangle,\quad U^{2j}|u\rangle=e^{i\phi 2^j}|u\rangle
$$
我们可以利用QPE算法寻找该算符本征值。QPE算符需要两组寄存器，一，第一组寄存器包含n个初态为|0>的量子比特，你的选取将会影响得到\phi的精度以及得到正确本征值的概率。二，第二组寄存器需要足够量子比特存储态|u&gt;。</p>

<p><img src="/img/QC_QPE_img1.png" alt="img1" /></p>

<p>由图可知，第一组寄存器的量子比特经过一个<code>Hadmard</code>门和<code>C-U^{2^j}</code>门
$$
|0\rangle\cdots|0\rangle|u\rangle\to Hadamard\to\frac{1}{\sqrt{2^n}}\left(|0\rangle+|1\rangle \right)\cdots\left(|0\rangle+|1\rangle \right)|u\rangle
$$</p>

<p>$$
\to C-U^{2^j}\to\frac{1}{\sqrt{2^n}}\left(|0\rangle+e^{i2^{n-1}\phi}|1\rangle \right)\cdots\left(|0\rangle+e^{i\phi}|1\rangle \right)|u\rangle=\frac{1}{\sqrt{2^n}}\sum_{y=0}^{2^n-1}e^{i\phi y}|y\rangle |u\rangle
$$</p>

<p>这里输出第一组寄存器中的\phi依赖于测量态的概率，但我们测量到的是态而非概率幅度，利用傅里叶变换可以将概率幅度存储的相位存储到量子态中。量子傅里叶逆变换为
$$
QFT^{-1}|y\rangle=\frac{1}{\sqrt{2^n}}\sum_{x=0}^{2^{n}-1}\exp(-2\pi i\frac{xy}{2^n})|x\rangle
$$
将\phi写成
$$
\phi=2\pi\left(\frac{a}{2^n}+\delta \right),\quad a=a_{n-1}\cdots a_0,0&lt;\delta<1/2^{n+1}
$$
将量子傅里叶逆变换作用到第一组寄存器的量子比特中
$$
\frac{1}{\sqrt{2^n}}\sum_{y=0}^{2^n-1}e^{i\phi y}|y\rangle |u\rangle\to\frac{1}{2^n}\sum_{x=0}^{2^n-1}\sum_{y=0}^{2^n-1}e^{2\pi i(a-x) y/2^n}e^{2\pi i\delta y}|x\rangle |u\rangle
$$
考虑里面的求和
$$
\sum_{y=0}^{2^n-1}e^{2\pi i(a-x) y/2^n}e^{2\pi i\delta y}
$$
当\delta=0时，
$$
a-x\neq 0,\frac{a-x}{2^n}<1,\sum_{y=0}^{n-1}e^{2\pi i(a-x) y/2^n}=\frac{1-q^{2^n}}{1-q}=0,q=e^{2\pi i(a-x) /2^n}
$$
所以只能取`a=x`的情况，输出态为|a>|u&gt;，可以得到本征值
$$
\phi=\frac{2\pi a}{2^n}
$$
当\delta不等于0时，则测到态|a&gt;|u&gt;的概率幅
$$
C_a=\frac{1}{2^n}\sum_{y=0}^{2^n-1}e^{2\pi i\delta y}&gt;\frac{2}{\pi}
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span>
<span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span><span class="p">,</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qutip.qip</span> <span class="kn">import</span> <span class="n">gates</span>
<span class="k">def</span> <span class="nf">user_gate1</span><span class="p">():</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    define C-U:control-qubit=0,u=1;conrol-qubit=1,u=[[1.,0.],[0.,-1.]]
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">mat_control0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_control1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_target0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_target1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mat_control0</span><span class="p">,</span><span class="n">mat_target0</span><span class="p">)</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mat_control1</span><span class="p">,</span><span class="n">mat_target1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span>
<span class="k">def</span> <span class="nf">user_gate2</span><span class="p">():</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    define C-U2:control-qubit=0,u=1;conrol-qubit=1,u=[[1.,0.],[0.,-1.]]
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">mat_control0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_control1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_target0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">mat_target1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mat_control0</span><span class="p">,</span><span class="n">mat_target0</span><span class="p">)</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mat_control1</span><span class="p">,</span><span class="n">mat_target1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span>
<span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">user_gates</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;C_U&#34;</span><span class="p">:</span><span class="n">user_gate1</span><span class="p">,</span><span class="s2">&#34;C_U2&#34;</span><span class="p">:</span><span class="n">user_gate2</span><span class="p">}</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;C_U&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;C_U2&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Fourier-transform,back
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">zero</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">input_0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span><span class="n">zero</span><span class="p">)</span>
<span class="n">u0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">input_0</span><span class="p">,</span><span class="n">u0</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">output
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">a_0</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a_1</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a_1</span><span class="p">,</span><span class="n">a_0</span><span class="p">,</span><span class="n">psit</span><span class="p">)</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>QC:quantum_FourierT</title>
			<link>https://boseliao.github.io/posts/qcquantum_fouriert/</link>
			<pubDate>Mon, 08 Jun 2020 17:39:53 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qcquantum_fouriert/</guid>
			<description>在一些数学或计算科学问题中，傅里叶变换是一种非常常用的手段，用于将待解决的问题转换成已知的问题。 $$ \tilde{f}(k)=\frac{1}{\sqrt{N}}\sum_{j=0}^{N-1}\exp(2\pi i\frac{jk}{N})f(j) $$ 相应的量子傅里叶变换是将算符作用到某一态|j&amp;gt;上得到由一组正交归一的基|0&amp;gt;,...,|N-1&amp;gt;线性叠加的态， $$ F|j\rangle=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}\exp(2\pi i\frac{jk}{N})|k\rangle $$ 结合上面两个式子， $$ F\sum_{j=0}^{N-1}f(j)|j\rangle=\sum_{k=0}^{N-1}\tilde{f}(k)|k\rangle $$ 显然F的矩阵形式 $$ F_{kj}=\frac{1}{\sqrt{2^n}}\exp(2\pi i\frac{jk}{2^n}) $$ 如果有n个量子比特，则N=2^n，量子态可以写成 $$ |j\rangle=|j_{n-1},\cdots,j_0\rangle;j=j_{n-1}2^{n-1}+\cdots+j_02^0 $$
$$ |k\rangle=|k_{n-1},\cdots,k_0\rangle;k=k_{n-1}2^{n-1}+\cdots+k_02^0 $$
所以(2)式可以写成 $$ F|j_{n-1},\cdots,j_0\rangle=\frac{1}{\sqrt{2^n}}\sum_{k_{n-1}=0}^{1}\cdots\sum_{k_0=0}^{1}\exp(2\pi ij\sum_l\frac{2^lk_l}{2^n})|k_{n-1}\cdots k_0\rangle $$
$$ l\to n-l,=\frac{1}{\sqrt{2^n}}\otimes_{l=1}^{n}\sum_{k_{n-l}=0}^1\exp(2\pi ij\sum_l\frac{2^lk_l}{2^n})|k_{n-l}\rangle_{n-l}=\frac{1}{\sqrt{2^n}}\otimes_{l=1}^{n}\left(|0\rangle_{n-l}+e^{2\pi ij/2^l}|1\rangle_{n-l} \right) $$
由于 $$ e^{2\pi in}=1,e^{2\pi ij/2^l}=e^{2\pi i0.j_{l-1}\cdots j_0} $$
电路构造 Hadmard门 $$ H|j_{n-1}\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{j_{n-1}}|1\rangle \right)=\frac{1}{\sqrt{2}}\left(|0\rangle+e^{2\pi ij_{n-1}/2}|1\rangle \right) $$ C-R_k，受控相移门 $$ R_k=\left[\begin{array}{lr} 1 \quad 0 \newline \newline 0 \quad e^{\frac{2\pi i}{2^k}} \end{array}\right] $$ 量子傅里叶变换电路</description>
			<content type="html"><![CDATA[

<p>在一些数学或计算科学问题中，傅里叶变换是一种非常常用的手段，用于将待解决的问题转换成已知的问题。
$$
\tilde{f}(k)=\frac{1}{\sqrt{N}}\sum_{j=0}^{N-1}\exp(2\pi i\frac{jk}{N})f(j)
$$
相应的量子傅里叶变换是将算符作用到某一态<code>|j&gt;</code>上得到由一组正交归一的基<code>|0&gt;,...,|N-1&gt;</code>线性叠加的态，
$$
F|j\rangle=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}\exp(2\pi i\frac{jk}{N})|k\rangle
$$
结合上面两个式子，
$$
F\sum_{j=0}^{N-1}f(j)|j\rangle=\sum_{k=0}^{N-1}\tilde{f}(k)|k\rangle
$$
显然F的矩阵形式
$$
F_{kj}=\frac{1}{\sqrt{2^n}}\exp(2\pi i\frac{jk}{2^n})
$$
如果有n个量子比特，则<code>N=2^n</code>，量子态可以写成
$$
|j\rangle=|j_{n-1},\cdots,j_0\rangle;j=j_{n-1}2^{n-1}+\cdots+j_02^0
$$</p>

<p>$$
|k\rangle=|k_{n-1},\cdots,k_0\rangle;k=k_{n-1}2^{n-1}+\cdots+k_02^0
$$</p>

<p>所以(2)式可以写成
$$
F|j_{n-1},\cdots,j_0\rangle=\frac{1}{\sqrt{2^n}}\sum_{k_{n-1}=0}^{1}\cdots\sum_{k_0=0}^{1}\exp(2\pi ij\sum_l\frac{2^lk_l}{2^n})|k_{n-1}\cdots k_0\rangle
$$</p>

<p>$$
l\to n-l,=\frac{1}{\sqrt{2^n}}\otimes_{l=1}^{n}\sum_{k_{n-l}=0}^1\exp(2\pi ij\sum_l\frac{2^lk_l}{2^n})|k_{n-l}\rangle_{n-l}=\frac{1}{\sqrt{2^n}}\otimes_{l=1}^{n}\left(|0\rangle_{n-l}+e^{2\pi ij/2^l}|1\rangle_{n-l} \right)
$$</p>

<p>由于
$$
e^{2\pi in}=1,e^{2\pi ij/2^l}=e^{2\pi i0.j_{l-1}\cdots j_0}
$$</p>

<h2 id="电路构造">电路构造</h2>

<p><code>Hadmard</code>门
$$
H|j_{n-1}\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^{j_{n-1}}|1\rangle \right)=\frac{1}{\sqrt{2}}\left(|0\rangle+e^{2\pi ij_{n-1}/2}|1\rangle \right)
$$
<code>C-R_k</code>，受控相移门
$$
R_k=\left[\begin{array}{lr}
1 \quad 0  \newline
\newline
0 \quad e^{\frac{2\pi i}{2^k}}
\end{array}\right]
$$
量子傅里叶变换电路</p>

<p><img src="/img/qc_FT.png" alt="img" /></p>

<p>图中输入，从上到下依次为
$$
j_{n-1},j_{n-2},\cdots,j_0
$$
输出
$$
\frac{1}{\sqrt{2^n}}\left(|0\rangle_{n-1}+e^{2\pi i0.j_{n-1}\cdots j_0}|1\rangle_{n-1} \right)\cdots\left(|0\rangle_0+e^{2\pi i0.j_0}|1\rangle_0 \right)
$$
对比我们的结果，需要对第<code>i</code>比特和<code>n-1-i</code>比特作用<code>SWAP</code>门。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span>
<span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span><span class="p">,</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qutip.qip</span> <span class="kn">import</span> <span class="n">gates</span>
<span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">8.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">j_0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">j_1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">j_2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">j_3</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">j_0</span><span class="p">,</span><span class="n">j_1</span><span class="p">,</span><span class="n">j_2</span><span class="p">,</span><span class="n">j_3</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">output
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">k_3</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">k_2</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">k_1</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">k_0</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></code></pre></div>
<p>逆傅里叶变换</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span>
<span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span><span class="p">,</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qutip.qip</span> <span class="kn">import</span> <span class="n">gates</span>
<span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">8.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CPHASE&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">j_0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">j_1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">j_2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">j_3</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">j_0</span><span class="p">,</span><span class="n">j_1</span><span class="p">,</span><span class="n">j_2</span><span class="p">,</span><span class="n">j_3</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">output
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">k_3</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">k_2</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">k_1</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">k_0</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>QC:quantum_algorithm</title>
			<link>https://boseliao.github.io/posts/qcquantum_algorithm/</link>
			<pubDate>Tue, 02 Jun 2020 07:46:20 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qcquantum_algorithm/</guid>
			<description>量子并行运算是一些量子算法中最基本的属性。它允许量子计算机对于不同的x能够同时计算f(x)。首先，考虑两个量子比特的幺正操作。 $$ U_f|x,y\rangle=|x,y\oplus f(x)\rangle $$ 其中，第一个寄存器储存自变量的数据，而第二个寄存器储存函数值。容易证明Uf操作总是一个幺正算符。 $$ \langle x\prime,y\prime|U_f|x,y\rangle=\langle x\prime,y\prime|x,y\oplus f(x)\rangle=\delta_{x\prime,x}\delta_{y\prime,y\oplus f(x)}=\delta_{x,x\prime}\delta_{y,y\prime\oplus f(x\prime)} $$
$$ =(\delta_{x,x\prime}\delta_{y,y\prime\oplus f(x\prime)})^*=(\langle x,y|U_f|x\prime,y\prime\rangle)^* $$
所以， $$ U_f=U_f^{\dagger} $$ 而 $$ U_f^2|x\rangle|y\rangle=|x\rangle|y\oplus f(x)\oplus f(x)\rangle=|x\rangle|y\rangle $$ 即 $$ U_f^2=1 $$ 任一二进制数可以表示为 $$ x=(x_{n-1},\cdots,x_0) $$ 对应的任一函数可以表示 $$ f(x^{(i)})=1,i=0,\cdots,m;f(x^{(i)})=0,i=m+1,\cdots,n-1 $$ 定义小项函数 $$ f^{(i)}(x)= \left[\begin{array}{lr} 1 \quad (x=x^{(i)}) \newline \newline 0 \quad (x \ne x^{(i)}) \end{array}\right. $$
则任一函数可以用小项函数来表示 $$ f(x)=f^{(1)}(x)\vee f^{(2)}(x)\vee\cdots f^{(m)}(x) $$ 每个小项函数对应于Cn-NOT操作。
量子加法器 对量子信息a和b进行加法，其进位储存在c $$ a=(a_{n-1},\cdots,a_0);b=(b_{n-1},\cdots,b_0);c=(c_{n},\cdots,c_0) $$ 量子加法器由两个模块组成，加法模块SUM(ai,bi,ci)和CARRY(ai,bi,ci)， $$ SUM(a_i,b_i,c_i):s_i=a_i\oplus b_i\oplus c_i $$</description>
			<content type="html"><![CDATA[

<p>量子并行运算是一些量子算法中最基本的属性。它允许量子计算机对于不同的x能够同时计算f(x)。首先，考虑两个量子比特的幺正操作。
$$
U_f|x,y\rangle=|x,y\oplus f(x)\rangle
$$
其中，第一个寄存器储存自变量的数据，而第二个寄存器储存函数值。容易证明Uf操作总是一个幺正算符。
$$
\langle x\prime,y\prime|U_f|x,y\rangle=\langle x\prime,y\prime|x,y\oplus f(x)\rangle=\delta_{x\prime,x}\delta_{y\prime,y\oplus f(x)}=\delta_{x,x\prime}\delta_{y,y\prime\oplus f(x\prime)}
$$</p>

<p>$$
=(\delta_{x,x\prime}\delta_{y,y\prime\oplus f(x\prime)})^*=(\langle x,y|U_f|x\prime,y\prime\rangle)^*
$$</p>

<p>所以，
$$
U_f=U_f^{\dagger}
$$
而
$$
U_f^2|x\rangle|y\rangle=|x\rangle|y\oplus f(x)\oplus f(x)\rangle=|x\rangle|y\rangle
$$
即
$$
U_f^2=1
$$
任一二进制数可以表示为
$$
x=(x_{n-1},\cdots,x_0)
$$
对应的任一函数可以表示
$$
f(x^{(i)})=1,i=0,\cdots,m;f(x^{(i)})=0,i=m+1,\cdots,n-1
$$
定义小项函数
$$
f^{(i)}(x)=
\left[\begin{array}{lr}
1 \quad (x=x^{(i)})  \newline
\newline
0 \quad (x \ne x^{(i)})
\end{array}\right.
$$</p>

<p>则任一函数可以用小项函数来表示
$$
f(x)=f^{(1)}(x)\vee f^{(2)}(x)\vee\cdots f^{(m)}(x)
$$
每个小项函数对应于<code>Cn-NOT</code>操作。</p>

<h2 id="量子加法器">量子加法器</h2>

<p>对量子信息a和b进行加法，其进位储存在c
$$
a=(a_{n-1},\cdots,a_0);b=(b_{n-1},\cdots,b_0);c=(c_{n},\cdots,c_0)
$$
量子加法器由两个模块组成，加法模块SUM(ai,bi,ci)和CARRY(ai,bi,ci)，
$$
SUM(a_i,b_i,c_i):s_i=a_i\oplus b_i\oplus c_i
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span>
<span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span><span class="p">,</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qutip.qip</span> <span class="kn">import</span> <span class="n">gates</span>
<span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">c_i</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a_i</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b_i</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">c_i</span><span class="p">,</span><span class="n">a_i</span><span class="p">,</span><span class="n">b_i</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">output
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">c_i</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a_i</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">s_i</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s_i</span><span class="p">)</span></code></pre></div>
<p>$$
CARRY(a_i,b_i,c_i):c_{i+1}=(a_i\wedge b_i)\oplus[c_i\wedge(a_i\oplus b_i)]
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;TOFFOLI&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;TOFFOLI&#34;</span><span class="p">,</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="c1">#psi0=(qt.basis(2,0)+qt.basis(2,1))/np.sqrt(2)</span>
<span class="c1">#psi0=qt.basis(2,1)</span>
<span class="n">c_i</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a_i</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b_i</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">up</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">c_i</span><span class="p">,</span><span class="n">a_i</span><span class="p">,</span><span class="n">b_i</span><span class="p">,</span><span class="n">up</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">output
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">c_i</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a_i</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">s_i</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c_iplus1</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></code></pre></div>
<p><code>cplus</code>等价于控制电路的<code>CNOT</code>门操作。<code>(a交b)cplus</code>等价于控制电路的<code>C2-NOT</code>门。整个电路由这两个模块组成</p>

<p><img src="/img/qc_algori_img1.png" alt="img1" /></p>

<h2 id="deutsch算法">Deutsch算法</h2>

<p>Deutsch算法是用于判断一个函数是“constant”(f(x)输出恒为0或1)或“balance”(f(x)输出有一半是0，一半是1)。判断的方法是基于如下的思路，
$$
U_f|x,y\rangle=|x,y\oplus f(x)\rangle,U_f|x\rangle(|0\rangle-|1\rangle)=(-1)^{f(x)}|x\rangle(|0\rangle-|1\rangle)
$$</p>

<p>电路</p>

<p><img src="/img/qc_algori_img2.png" alt="img2" /></p>

<p>输出
$$
\left[\begin{array}{lr}
\pm|0\rangle\otimes\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle) \quad (f(x)=constance)  \newline
\newline
\pm|1\rangle\otimes\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle) \quad (f(x)=balance)
\end{array}\right.
$$
可见只要测量<code>psi0</code>，就可以判断f(x)的性质。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span>
<span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span><span class="p">,</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qutip.qip</span> <span class="kn">import</span> <span class="n">gates</span>
<span class="k">def</span> <span class="nf">user_gate1</span><span class="p">():</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    define U_f(x):f(0)=1,f(1)=0
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">mat_control0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_control1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_target0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat_target1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mi">1</span><span class="p">]]),</span><span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">mat</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mat_control0</span><span class="p">,</span><span class="n">mat_target0</span><span class="p">)</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mat_control1</span><span class="p">,</span><span class="n">mat_target1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span>
<span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">user_gates</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;U_f(x)&#34;</span><span class="p">:</span><span class="n">user_gate1</span><span class="p">}</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;U_f(x)&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="n">psit0</span><span class="o">=</span><span class="n">psit</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">psit0</span><span class="p">)</span></code></pre></div>
<p>这种方法相对于经典的方法缩短了一半的步骤。</p>

<h2 id="deutsch-jozsa">Deutsch-Jozsa</h2>

<p>对于n个量子态的函数映射
$$
f:\left(0,1\right)^n\to\left(0,1\right)
$$
输入储存于量子态|x&gt;中
$$
x=\left(x_{n-1},\cdots,x_0 \right)
$$
同理
$$
U_f|x\rangle(|0\rangle-|1\rangle)=\prod_{i=0}^{n-1}(-1)^{f(x_i)}|x\rangle(|0\rangle-|1\rangle)
$$
任意态经过Hadamard门
$$
H^{\otimes n}|x\rangle=\frac{1}{\sqrt{2^n}}\sum_{y_{n-1}=0}^1\cdots\sum_{y_0=0}^1(-1)^{\sum_ix_iy_i}|y_{n-1}\cdots y_0\rangle=\frac{1}{\sqrt{2^n}}\sum_y(-1)^y|y\rangle
$$
电路与单态的<code>Deutsch</code>算法电路相同，但是对第一个量子态的Hadamard门变成上式中n量子态Hadamard门，输出为，
$$
\frac{1}{2^n}\sum_x\sum_y(-1)^{f(x)+xy}|y\rangle\frac{1}{\sqrt{2}}\left(|0\rangle-|1\rangle\right)
$$
当f=constance时，
$$
\frac{1}{2^n}\sum_x(-1)^{f(x)+xy}|y\rangle=\frac{(-1)^{c}}{2^n}\sum_x(-1)^{xy}|y\rangle=\frac{(-1)^{c}}{2^n}\prod_{i=0}^{n-1}\sum_{x_i=0}^{1}(-1)^{x_iy_i}|y\rangle=\frac{(-1)^{c}}{2^n}\prod_{i=0}^{n-1}\left[1+(-1)^{y_i}\right]
$$
显然只有当y=|0&hellip;0&gt;时，该系数才不为零，即只能测到该态。</p>

<p>当f=balance时，考虑y=|0&hellip;0&gt;态的系数
$$
\frac{1}{2^n}\sum_x(-1)^{f(x)}|y_0\rangle=\frac{1}{2^n}\left[2^{n-1}(-1)^0+2^{n-1}(-1)^1\right]|y_0\rangle=0|y_0\rangle
$$
即无法测到该态</p>
]]></content>
		</item>
		
		<item>
			<title>QC:qubit_gate</title>
			<link>https://boseliao.github.io/posts/qcqubit_gate/</link>
			<pubDate>Wed, 27 May 2020 21:27:15 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qcqubit_gate/</guid>
			<description>利用一些装置可以实现对自旋态的操控，例如核磁共振(NMR)
单量子比特 sigma_x泡利算符X，对应于经典的NOT门 $$ \sigma_x|x\rangle=|1-x\rangle $$
from qutip.qip.circuit import QubitCircuit, Gate from qutip.qip import gates qc=QubitCircuit(N=1) def user_gate(): #sigma_x mat = np.array([[0.,1.0],[1., 0.]]) return qt.Qobj(mat, dims=[[2], [2]]) qc.user_gates={&amp;#34;sigma_x&amp;#34;:user_gate} qc.add_gate(&amp;#34;sigma_x&amp;#34;,targets=[0]) U_list = qc.propagators() from qutip.qip.operations import gate_sequence_product U = gate_sequence_product(U_list) psi0=qt.basis(2,0) psit=U*psi0 b=qt.Bloch() b.add_states(psi0) b.add_states(psit) b.save(&amp;#34;qc_gate.png&amp;#34;) b.show() sigma_z泡利算符Z $$ \sigma_z|x\rangle=(-1)^x|x\rangle $$
def user_gate(): #sigma_z mat = np.array([[1.,0.],[0., -1.]]) return qt.Qobj(mat, dims=[[2], [2]]) qc.user_gates={&amp;#34;sigma_z&amp;#34;:user_gate} qc.add_gate(&amp;#34;sigma_z&amp;#34;,targets=[0]) 旋转门(rotation gate) RX沿着X轴旋转 $$ R_x(\theta)(\alpha|0\rangle+\beta|1\rangle)=(\alpha\cos(\frac{\theta}{2})-i\beta\sin(\frac{\theta}{2}))|0\rangle+(\beta\cos(\frac{\theta}{2})-i\alpha\sin(\frac{\theta}{2}))|1\rangle $$</description>
			<content type="html"><![CDATA[

<p>利用一些装置可以实现对自旋态的操控，例如核磁共振(NMR)</p>

<h2 id="单量子比特">单量子比特</h2>

<p><code>sigma_x</code>泡利算符X，对应于经典的<code>NOT</code>门
$$
\sigma_x|x\rangle=|1-x\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span><span class="p">,</span> <span class="n">Gate</span>
<span class="kn">from</span> <span class="nn">qutip.qip</span> <span class="kn">import</span> <span class="n">gates</span>
<span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user_gate</span><span class="p">():</span>
    <span class="c1">#sigma_x</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.0</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">user_gates</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;sigma_x&#34;</span><span class="p">:</span><span class="n">user_gate</span><span class="p">}</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;sigma_x&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="n">b</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Bloch</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psi0</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psit</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&#34;qc_gate.png&#34;</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/qc_gate_img1.png" alt="img1" /></p>

<p><code>sigma_z</code>泡利算符Z
$$
\sigma_z|x\rangle=(-1)^x|x\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">user_gate</span><span class="p">():</span>
    <span class="c1">#sigma_z</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">qt</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">user_gates</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;sigma_z&#34;</span><span class="p">:</span><span class="n">user_gate</span><span class="p">}</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;sigma_z&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></div>
<p><img src="/img/qc_gate_img2.png" alt="img2" /></p>

<h3 id="旋转门-rotation-gate">旋转门(rotation gate)</h3>

<p><code>RX</code>沿着X轴旋转
$$
R_x(\theta)(\alpha|0\rangle+\beta|1\rangle)=(\alpha\cos(\frac{\theta}{2})-i\beta\sin(\frac{\theta}{2}))|0\rangle+(\beta\cos(\frac{\theta}{2})-i\alpha\sin(\frac{\theta}{2}))|1\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RX&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="n">b</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Bloch</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psi0</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psit</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&#34;qc_gate_img4.png&#34;</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/qc_gate_img4.png" alt="img4" /></p>

<p>同理，<code>RY</code>，<code>RZ</code>表示沿着X，Z轴旋转
$$
R_y(\theta)(\alpha|0\rangle+\beta|1\rangle)=(\alpha\cos(\frac{\theta}{2})-\beta\sin(\frac{\theta}{2}))|0\rangle+(\beta\cos(\frac{\theta}{2})+\alpha\sin(\frac{\theta}{2}))|1\rangle
$$</p>

<p>$$
R_z(\theta)(\alpha|0\rangle+\beta|1\rangle)=\alpha e^{-i\theta/2}|0\rangle+\beta e^{i\theta/2}|1\rangle
$$</p>

<p>沿任意轴的旋转可以表示为
$$
R_n(\theta)=e^{-i\theta n\sigma}=\cos(\frac{\theta}{2})I-i\sin(\frac{\theta}{2})n\sigma
$$
<code>Hadamard</code>
$$
H|x\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle+(-1)^x|1\rangle\right)
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span></code></pre></div>
<p><img src="/img/qc_gate_img3.png" alt="img3" /></p>

<p>任意态的制备，这里忽略了整体相位，对量子态不影响
$$
|0\rangle\to|\psi\rangle=R_z(\frac{\pi}{2}+\phi)HR_z(\theta)H|0\rangle=\cos(\frac{\theta}{2})|0\rangle+e^{i\phi}\sin(\frac{\theta}{2})|1\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RZ&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RZ&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="n">b</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Bloch</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psi0</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psit</span><span class="p">)</span>
<span class="c1">#b.save(&#34;qc_gate_img4.png&#34;)</span>
<span class="n">b</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/qc_gate_img5.png" alt="img5" /></p>

<h3 id="相移门-phase-gate">相移门(phase gate)</h3>

<p><code>PHASEGATE</code>，当target qubit为1态时才发生相移
$$
P(\theta)|x\rangle=xe^{i\theta}|x\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">qc</span><span class="o">=</span><span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;PHASEGATE&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">psit</span><span class="o">=</span><span class="n">U</span><span class="o">*</span><span class="n">psi0</span>
<span class="n">b</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Bloch</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psi0</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_states</span><span class="p">(</span><span class="n">psit</span><span class="p">)</span>
<span class="c1">#b.save(&#34;qc_gate_img6.png&#34;)</span>
<span class="n">b</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/qc_gate_img6.png" alt="img6" /></p>

<h2 id="双量子比特">双量子比特</h2>

<p>控制算符，即“If A is true, then do B”。输入分别为”control qubit“以及”target qubit“，输出只会改变”target qubit“的状态。</p>

<p><code>CNOT</code>，即”control-NOT“，受控非门
$$
C_1|c\rangle|t\rangle=|c\rangle|c\otimes t\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">gates</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">control</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True
</span><span class="s2">Qobj data =
</span><span class="s2">[[1. 0. 0. 0.]
</span><span class="s2"> [0. 1. 0. 0.]
</span><span class="s2"> [0. 0. 0. 1.]
</span><span class="s2"> [0. 0. 1. 0.]]
</span><span class="s2">&#34;&#34;&#34;</span></code></pre></div>
<p>广义<code>CNOT</code>门，
$$
C_2|t\rangle|c\rangle=|t\otimes c\rangle|c\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">gates</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">control</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">=
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></div>
<p>产生两对贝尔基
$$
|\phi^{\pm}\rangle=\frac{1}{\sqrt{2}}\left(|00\rangle\pm|11\rangle \right)\quad|\psi^{\pm}\rangle=\frac{1}{\sqrt{2}}\left(|01\rangle\pm|10\rangle \right)
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;SNOT&#34;</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></div>
<p>输入与对应输出，
$$
|00\rangle\to|\phi^+\rangle,|10\rangle\to|\phi^-\rangle,|01\rangle\to|\psi^+\rangle,|11\rangle\to|\psi^-\rangle
$$
<code>CPHASE</code>，即受控相移门，当control qubit和target qubit 都为1态时发生相移</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">gates</span><span class="o">.</span><span class="n">cphase</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">=
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;PHASEGATE&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">theta</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;PHASEGATE&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">theta</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;PHASEGATE&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">theta</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></div>
<p><code>SWAP</code>，即交换门
$$
SWAP|x\rangle|y\rangle=C_1C_2C_1|x\rangle|y\rangle=|y\rangle|x\rangle
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">gates</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">=
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></div>
<p>事实上任意两比特的受控U门(C-U)都可以由单比特门以及<code>CNOT</code>门构成。
$$
|c\rangle|t\rangle\to|c\rangle U^{c}|t\rangle
$$
任意的单比特操作可以写成
$$
U=\phi(\delta)R_z(\alpha)R_y(\theta)R_z(\beta)=\begin{bmatrix}
   e^{i(\delta-\frac{\alpha+\beta}{2})}\cos\frac{\theta}{2} &amp; -e^{i(\delta-\frac{\alpha-\beta}{2})}\sin\frac{\theta}{2} \newline
   e^{i(\delta+\frac{\alpha-\beta}{2})}\sin\frac{\theta}{2} &amp; e^{i(\delta+\frac{\alpha+\beta}{2})}\cos\frac{\theta}{2}<br />
  \end{bmatrix}
$$
设
$$
I=ABC,U=\phi(\delta)A\sigma_xB\sigma_xC
$$
则
$$
A=R_z(\alpha)R_y(\theta/2),B=R_y(-\theta/2)R_z(-\frac{\alpha+\beta}{2}),C=R_z(\frac{\beta-\alpha}{2})
$$
所以受控U门(C-U)可以写成，上标表示control qubit，下标表示target qubit。
$$
CU=\phi^0_1(\delta)A_1C^0_1B_1C^0_1C_1=P_0(\delta)A_1C^0_1B_1C^0_1C_1
$$
相位的控制算符</p>

<p><img src="/img/qc_gate_img7.png" alt="img7" /></p>

<p>电路可以表示为</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RZ&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="p">(</span><span class="n">beta</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RZ&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=-</span><span class="p">(</span><span class="n">beta</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RY&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=-</span><span class="n">theta</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;CNOT&#34;</span><span class="p">,</span><span class="n">control</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RY&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">theta</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;RZ&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">alpha</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&#34;PHASEGATE&#34;</span><span class="p">,</span><span class="n">arg_value</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></div>
<h2 id="三量子比特">三量子比特</h2>

<p><code>toffoli</code>，即<code>C2-NOT</code>门。如果两个control qubit都处于|1&gt;态，则对target qubit作用NOT算符。</p>

<p><img src="/img/qc_gate_img8.png" alt="img8" /></p>

<p>这里
$$
U=\sigma_x,V=\sqrt{U}=(1-i)(1+i\sigma_x)/2
$$
对于一般的算符U，此电路都是成立的。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">gates</span><span class="o">.</span><span class="n">toffoli</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">target</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></code></pre></div>
<p><code>fredkin</code>如果control的目标量子比特处于|1&gt;态，则对targets的目标量子比特作用SWAP算符</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">gates</span><span class="o">.</span><span class="n">fredkin</span><span class="p">(</span><span class="n">control</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span></code></pre></div>
<p>特别的，当control qubit大于等于三时，即<code>Cn-U,n&gt;2</code>，控制电路</p>

<p><img src="/img/qc_gate_img9.png" alt="img9" /></p>

<h2 id="通用门-universal-quantum-gates">通用门(Universal quantum gates)</h2>

<p>在经典计算中，任何的函数都可以用一组通用门来描述。相应的，在量子计算中任意的幺正算符也可以用一组通用门描述，<code>Hadamard</code>，<code>CNOT</code>，<code>PHASEGATE（pi/4）</code>，<code>PHASEGATE(pi/8)</code></p>

<h2 id="测量-measurement">测量(Measurement)</h2>

<p>不失一般性的，可以假设在量子电路的末端测量未测量的量子比特</p>

<p><img src="/img/qc_gate_img10.png" alt="img10" /></p>

<p>对bell基的测量</p>

<p><img src="/img/qc_gate_img11.png" alt="img11" /></p>

<p>测量与控制算符的对易关系，单线表示量子信息的传递，双线表示经典信息的传递</p>

<p><img src="/img/qc_gate_ing12.png" alt="img12" /></p>
]]></content>
		</item>
		
		<item>
			<title>QC:spin</title>
			<link>https://boseliao.github.io/posts/qcspin/</link>
			<pubDate>Tue, 26 May 2020 19:31:24 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qcspin/</guid>
			<description>磁偶极子在磁场中的势能 $$ H=U=-\mu B $$ \mu表示磁矩的大小和方向。磁偶极子受到的磁场梯度力为 $$ F=-\nabla U=\nabla (\mu B) $$ 自旋的磁矩可以表示为 $$ \mu =-\frac{1}{2}g\mu_B\sigma $$ 自旋在磁场中哈密顿量 $$ H=-\mu B=\frac{1}{2}g\mu_B\sigma B=\frac{1}{2}\hbar\gamma\sigma B $$ 著名的Stern-Gerlach实验证明了自旋磁矩的量子化
在图中，电子经过第一个SG装置会分裂成两部分|n+&amp;gt;和|n-&amp;gt;，之后 |n+&amp;gt;经过第二个SG装置继续分成两部分|m+&amp;gt;和|m-&amp;gt;， $$ P(|n+\rangle\to|m+\rangle)=\frac{1}{2}\left(1+nm \right) $$
$$ P(|n+\rangle\to|m-\rangle)=\frac{1}{2}\left(1-nm \right) $$
选择Z方向的本征态为基失 $$ |Z+\rangle=|0\rangle ,|Z-\rangle=|1\rangle $$ 则 $$ |n+\rangle=\alpha|0\rangle+\beta|1\rangle $$ 将m设置为Z方向 $$ P(|n+\rangle\to|0\rangle)=\frac{1}{2}\left(1+nZ \right)=|\alpha|^2 $$ 在球坐标中 $$ n=(sin(\theta)cos(\phi),sin(\theta)sin(\phi),cos(\theta)) $$ 任一量子态可以写成 $$ |n+\rangle=cos(\theta/2)|0\rangle+sin(\theta/2)e^{i\phi}|1\rangle $$ 在Bloch球中表示任一量子态
b=qt.Bloch() pnt = [1/np.sqrt(3),1/np.sqrt(3),1/np.sqrt(3)] b.add_points(pnt) vec = [0,1,0] b.add_vectors(vec) b.show() 不难证明n方向的角动量 $$ S(n)=n\sigma=n_x\sigma_x+n_y\sigma_y+n_z\sigma_z $$ 考虑自旋在磁场中的时间演化，哈密顿量写成 $$ H=\frac{1}{2}\hbar\gamma\sigma_zB_z $$ 设初态处于 $$ |\psi(0)\rangle=\alpha|0\rangle+\beta|1\rangle $$ 时间演化 $$ |\psi(t)\rangle=e^{-i\gamma B_z\sigma_z/2}(\alpha|0\rangle+\beta|1\rangle)=\alpha|0\rangle+\beta e^{i\gamma B_zt}|1\rangle $$ </description>
			<content type="html"><![CDATA[<p>磁偶极子在磁场中的势能
$$
H=U=-\mu B
$$
<code>\mu</code>表示磁矩的大小和方向。磁偶极子受到的磁场梯度力为
$$
F=-\nabla U=\nabla (\mu B)
$$
自旋的磁矩可以表示为
$$
\mu =-\frac{1}{2}g\mu_B\sigma
$$
自旋在磁场中哈密顿量
$$
H=-\mu B=\frac{1}{2}g\mu_B\sigma B=\frac{1}{2}\hbar\gamma\sigma B
$$
著名的Stern-Gerlach实验证明了自旋磁矩的量子化</p>

<p><img src="/img/QC:spin_img1.png" alt="img1" /></p>

<p>在图中，电子经过第一个SG装置会分裂成两部分<code>|n+&gt;</code>和<code>|n-&gt;</code>，之后 <code>|n+&gt;</code>经过第二个SG装置继续分成两部分<code>|m+&gt;</code>和<code>|m-&gt;</code>，
$$
P(|n+\rangle\to|m+\rangle)=\frac{1}{2}\left(1+nm \right)
$$</p>

<p>$$
P(|n+\rangle\to|m-\rangle)=\frac{1}{2}\left(1-nm \right)
$$</p>

<p>选择Z方向的本征态为基失
$$
|Z+\rangle=|0\rangle ,|Z-\rangle=|1\rangle
$$
则
$$
|n+\rangle=\alpha|0\rangle+\beta|1\rangle
$$
将m设置为Z方向
$$
P(|n+\rangle\to|0\rangle)=\frac{1}{2}\left(1+nZ \right)=|\alpha|^2
$$
在球坐标中
$$
n=(sin(\theta)cos(\phi),sin(\theta)sin(\phi),cos(\theta))
$$
任一量子态可以写成
$$
|n+\rangle=cos(\theta/2)|0\rangle+sin(\theta/2)e^{i\phi}|1\rangle
$$
在Bloch球中表示任一量子态</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">b</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">Bloch</span><span class="p">()</span>
<span class="n">pnt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_points</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
<span class="n">vec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_vectors</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/QC:spin_img2.png" alt="img2" /></p>

<p>不难证明n方向的角动量
$$
S(n)=n\sigma=n_x\sigma_x+n_y\sigma_y+n_z\sigma_z
$$
考虑自旋在磁场中的时间演化，哈密顿量写成
$$
H=\frac{1}{2}\hbar\gamma\sigma_zB_z
$$
设初态处于
$$
|\psi(0)\rangle=\alpha|0\rangle+\beta|1\rangle
$$
时间演化
$$
|\psi(t)\rangle=e^{-i\gamma B_z\sigma_z/2}(\alpha|0\rangle+\beta|1\rangle)=\alpha|0\rangle+\beta e^{i\gamma B_zt}|1\rangle
$$
<img src="/img/QC:spin_img3.png" alt="img3" /></p>
]]></content>
		</item>
		
		<item>
			<title>QuTip:spin_chain</title>
			<link>https://boseliao.github.io/posts/qutipspin_chain/</link>
			<pubDate>Mon, 25 May 2020 17:50:07 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qutipspin_chain/</guid>
			<description>考虑一维的ISing模型，其哈密顿量， $$ \begin{equation} H=-\frac{1}{2}\sum_n^Nh_n\sigma_z(n)-\frac{1}{2}\sum_n^{N-1}\sum_{i=x,y,z}J_i^{(n)}\sigma_i(n)\sigma_i(n+1) \end{equation} $$ 利用主方程计算其动力学的演化
def integrate(N,h,Jx,Jy,Jz,psi0,tlist,gamma,solver): si=qt.qeye(2) sx=qt.sigmax() sy=qt.sigmay() sz=qt.sigmaz() sx_list=[] sy_list=[] sz_list=[] #construct sigma_x(n),sigma_y(n),sigma_z(n)  for n in range(N): op_list=[] for m in range(N): op_list.append(si) op_list[n] = sx sx_list.append(qt.tensor(op_list)) op_list[n] = sy sy_list.append(qt.tensor(op_list)) op_list[n] = sz sz_list.append(qt.tensor(op_list)) # construct the hamiltonian H = 0 # energy splitting terms for n in range(N): H += - 0.5 * h[n] * sz_list[n] # interaction terms for n in range(N-1): H += - 0.</description>
			<content type="html"><![CDATA[<p>考虑一维的ISing模型，其哈密顿量，
$$
\begin{equation}
H=-\frac{1}{2}\sum_n^Nh_n\sigma_z(n)-\frac{1}{2}\sum_n^{N-1}\sum_{i=x,y,z}J_i^{(n)}\sigma_i(n)\sigma_i(n+1)
\end{equation}
$$
利用主方程计算其动力学的演化</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">Jx</span><span class="p">,</span><span class="n">Jy</span><span class="p">,</span><span class="n">Jz</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,</span><span class="n">gamma</span><span class="p">,</span><span class="n">solver</span><span class="p">):</span>
    <span class="n">si</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">sx</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
    <span class="n">sy</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">()</span>
    <span class="n">sz</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
    <span class="n">sx_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">sy_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">sz_list</span><span class="o">=</span><span class="p">[]</span>
<span class="c1">#construct sigma_x(n),sigma_y(n),sigma_z(n)    </span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">op_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
            
        <span class="n">op_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span>
        <span class="n">sx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">op_list</span><span class="p">))</span>

        <span class="n">op_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span>
        <span class="n">sy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">op_list</span><span class="p">))</span>

        <span class="n">op_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sz</span>
        <span class="n">sz_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">op_list</span><span class="p">))</span>

    <span class="c1"># construct the hamiltonian</span>
    <span class="n">H</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># energy splitting terms</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">+=</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">sz_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="c1"># interaction terms</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">+=</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Jx</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">sx_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">sx_list</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">H</span> <span class="o">+=</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Jy</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">sy_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">sy_list</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">H</span> <span class="o">+=</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Jz</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">sz_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">sz_list</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># collapse operators</span>
    <span class="n">c_op_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># spin dephasing</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gamma</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">c_op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">*</span> <span class="n">sz_list</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

    <span class="c1"># evolve and calculate expectation values</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&#34;me&#34;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_op_list</span><span class="p">,</span> <span class="n">sz_list</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&#34;mc&#34;</span><span class="p">:</span>
        <span class="n">ntraj</span> <span class="o">=</span> <span class="mi">250</span> 
        <span class="n">result</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">c_op_list</span><span class="p">,</span> <span class="n">sz_list</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">expect</span>

<span class="c1">#</span>
<span class="c1"># set up the calculation</span>
<span class="c1">#</span>
<span class="n">solver</span> <span class="o">=</span> <span class="s2">&#34;me&#34;</span>   <span class="c1"># use the ode solver</span>
<span class="c1">#solver = &#34;mc&#34;   # use the monte-carlo solver</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>            <span class="c1"># number of spins</span>

<span class="c1"># array of spin energy splittings and coupling strengths. here we use</span>
<span class="c1"># uniform parameters, but in general we don&#39;t have too</span>
<span class="n">h</span>  <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> 
<span class="n">Jz</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">Jx</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">Jy</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="c1"># dephasing rate</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># intial state, first spin in state |1&gt;, the rest in state |0&gt;</span>
<span class="n">psi_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">psi_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">psi_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">psi_list</span><span class="p">)</span>

<span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="n">sz_expt</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">Jx</span><span class="p">,</span> <span class="n">Jy</span><span class="p">,</span> <span class="n">Jz</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
<span class="c1">#plot the result</span>
<span class="n">qt</span><span class="o">.</span><span class="n">qsave</span><span class="p">(</span><span class="n">sz_expt</span><span class="p">,</span><span class="s1">&#39;sz_expet&#39;</span><span class="p">)</span>
<span class="n">sz_expt_load</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">qload</span><span class="p">(</span><span class="s1">&#39;sz_expet&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">sz_expt_load</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\langle\sigma_z^{(</span><span class="si">%d</span><span class="s1">)}\rangle$&#39;</span><span class="o">%</span><span class="n">n</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Time [ns]&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\langle\sigma_z\rangle&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Dynamics of a Heisenberg spin chain&#39;</span><span class="p">);</span></code></pre></div>
<p><img src="/img/spin_chain_img1.png" alt="img1" /></p>

<p>将<code>collapse operators</code>修改成如下</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"> <span class="c1"># collapse operators</span>
    <span class="n">c_op_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">n_th_a</span><span class="o">=</span><span class="mf">0.0</span> <span class="c1">#temperature with average of excitations</span>
    <span class="n">rate</span><span class="o">=</span><span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n_th_a</span><span class="p">)</span>

    <span class="c1"># spin dephasing</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gamma</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">c_op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rate</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">*</span> <span class="n">sm_list</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="n">rate</span><span class="o">=</span><span class="n">gamma</span><span class="o">*</span><span class="n">n_th_a</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gamma</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">c_op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rate</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">*</span> <span class="n">sp_list</span><span class="p">[</span><span class="n">n</span><span class="p">])</span></code></pre></div>
<p>当<code>n_th_a=100</code>时，即环境温度较高时，系统处于熵最大的状态</p>

<p><img src="/img/spin_chain_img2.png" alt="img2" /></p>

<p>当<code>n_th_a=2</code>时，</p>

<p><img src="/img/spin_chain_img3.png" alt="img3" /></p>

<p>当<code>n_th_a=0</code>时，低温时，系统处于能量最低，最有序的状态（自旋都朝着同一个方向）</p>

<p><img src="/img/spin_chain_img4.png" alt="img4" /></p>
]]></content>
		</item>
		
		<item>
			<title>QuTip:HEOM</title>
			<link>https://boseliao.github.io/posts/qutipheom/</link>
			<pubDate>Wed, 20 May 2020 16:20:42 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qutipheom/</guid>
			<description>级联运动方程是用于计算非马尔科夫动力学的最普遍的工具，
$$\frac{\partial}{\partial t}\rho^n_{j_1\dots j_K}=-\left[iH_s^{\times}+n\gamma+\sum_{k=1}^Kj_k\nu_k-\Xi \right]\rho^n_{j_1\dots j_K}+V^{\times}\rho^{n+1}_{j_1\dots j_K}$$
$$V^{\times}\sum_{k=1}^K\rho^n_{j_1\dots j_k+1\dots J_K}+n\Theta\rho^{n-1}_{j_1\dots J_K}+\sum_{k=1}^Kj_k\nu_k\Psi_k\rho^n_{j_1\dots j_k-1\dots j_K }$$
其中$\rho^n_{j_1\dots jK}$表示n阶辅助密度矩阵，对它的求解依赖于n+1，n-1，n阶辅助矩阵，即此方程是不封闭的。而最后要求得的真正的约化密度矩阵是$\rho^0{0\dots 0}$，见图假设（K=2）
由图可知，可以做如下截断N=n=j1+...+jK，截断方程
$$\frac{\partial}{\partial t}\rho^n_{j_1\dots j_K}=-\left[iH_s^{\times}-\Xi \right]\rho^n_{j_1\dots j_K}$$
这里，目前只能求解洛伦兹谱的谱密度$$J(\omega)=\frac{\eta}{2\pi}\frac{\omega\gamma^2}{\gamma^2+\omega^2}$$其中$\eta$是“system-bath coupling strength”，$\gamma$表示&amp;rdquo;Bath spectral density cutoff frequency&amp;rdquo;。
这里对文献Non-Markovian and Non-Perturbative Entanglement Dynamics of Biomolecular Excitons进行了follow，
import numpy as np import matplotlib.pyplot as plt import qutip as qt from qutip.nonmarkov import heom &amp;#34;&amp;#34;&amp;#34; initial attribution self.configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann, renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats) H_sys : Qobj System Hamiltonian coup_op : Qobj Operator describing the coupling between system and bath.</description>
			<content type="html"><![CDATA[<p>级联运动方程是用于计算非马尔科夫动力学的最普遍的工具，</p>

<p>$$\frac{\partial}{\partial t}\rho^n_{j_1\dots j_K}=-\left[iH_s^{\times}+n\gamma+\sum_{k=1}^Kj_k\nu_k-\Xi \right]\rho^n_{j_1\dots j_K}+V^{\times}\rho^{n+1}_{j_1\dots j_K}$$</p>

<p>$$V^{\times}\sum_{k=1}^K\rho^n_{j_1\dots j_k+1\dots J_K}+n\Theta\rho^{n-1}_{j_1\dots J_K}+\sum_{k=1}^Kj_k\nu_k\Psi_k\rho^n_{j_1\dots j_k-1\dots j_K }$$</p>

<p>其中$\rho^n_{j_1\dots j<em>K}$表示n阶辅助密度矩阵，对它的求解依赖于n+1，n-1，n阶辅助矩阵，即此方程是不封闭的。而最后要求得的真正的约化密度矩阵是$\rho^0</em>{0\dots 0}$，见图假设（K=2）</p>

<p><img src="/img/HEOMimg1.png" alt="img1" /></p>

<p>由图可知，可以做如下截断<code>N=n=j1+...+jK</code>，截断方程</p>

<p>$$\frac{\partial}{\partial t}\rho^n_{j_1\dots j_K}=-\left[iH_s^{\times}-\Xi \right]\rho^n_{j_1\dots j_K}$$</p>

<p>这里，目前只能求解洛伦兹谱的谱密度$$J(\omega)=\frac{\eta}{2\pi}\frac{\omega\gamma^2}{\gamma^2+\omega^2}$$其中$\eta$是“system-bath coupling strength”，$\gamma$表示&rdquo;Bath spectral density cutoff frequency&rdquo;。</p>

<p>这里对文献<a href="http://cpl.iphy.ac.cn/10.1088/0256-307X/28/8/089201">Non-Markovian and Non-Perturbative Entanglement Dynamics of
Biomolecular Excitons</a>进行了follow，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">qutip</span> <span class="kn">as</span> <span class="nn">qt</span>
<span class="kn">from</span> <span class="nn">qutip.nonmarkov</span> <span class="kn">import</span> <span class="n">heom</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">initial attribution
</span><span class="s2">self.configure(H_sys, coup_op, coup_strength, temperature,
</span><span class="s2">                     N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,
</span><span class="s2">                     renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats)
</span><span class="s2">H_sys : Qobj
</span><span class="s2">        System Hamiltonian
</span><span class="s2">coup_op : Qobj
</span><span class="s2">        Operator describing the coupling between system and bath.
</span><span class="s2">coup_strength : float
</span><span class="s2">        Coupling strength.
</span><span class="s2">temperature : float
</span><span class="s2">        Bath temperature, in units corresponding to planck
</span><span class="s2">N_cut : int
</span><span class="s2">        Cutoff parameter for the bath
</span><span class="s2">N_exp : int
</span><span class="s2">        Number of exponential terms used to approximate the bath correlation
</span><span class="s2">        functions
</span><span class="s2">cut_freq : float
</span><span class="s2">        Bath spectral density cutoff frequency.
</span><span class="s2">        ---------------------------------------
</span><span class="s2">        Function
</span><span class="s2">        HEOMSolver.reset(self) : Reset any attributes to default values
</span><span class="s2">        run(self, rho0, tlist) :
</span><span class="s2">rho0 : Qobj
</span><span class="s2">            Initial state (density matrix) of the system.
</span><span class="s2">tlist : list
</span><span class="s2">            Time over which system evolves.
</span><span class="s2">Returns
</span><span class="s2">        -------
</span><span class="s2">        results : :class:`qutip.solver.Result`
</span><span class="s2">        Object storing all results from the simulation.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">delta</span><span class="o">=</span><span class="mi">500</span><span class="p">;</span><span class="n">J</span><span class="o">=</span><span class="mi">50</span>
<span class="n">H_sys</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">delta</span><span class="o">*</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>\
<span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()))</span><span class="o">+</span><span class="n">J</span><span class="o">*</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">())</span>\
<span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmay</span><span class="p">()))</span>
<span class="n">cou_op</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()))</span>
<span class="n">cou_strength</span><span class="o">=</span><span class="mf">1.0</span>
<span class="n">temperature</span><span class="o">=</span><span class="mf">300.0</span>
<span class="n">N_cut</span><span class="o">=</span><span class="mi">8</span>
<span class="n">N_exp</span><span class="o">=</span><span class="mi">3</span>
<span class="n">planck</span><span class="o">=</span><span class="mf">1.0</span>
<span class="n">cut_freq</span><span class="o">=</span><span class="mi">500</span>
<span class="n">tlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">401</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>\
               <span class="o">+</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">rho0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">psi0</span><span class="p">)</span>
<span class="n">num1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
<span class="n">num2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">HEOM1</span><span class="o">=</span><span class="n">heom</span><span class="o">.</span><span class="n">HSolverDL</span><span class="p">(</span><span class="n">H_sys</span><span class="p">,</span><span class="n">cou_op</span><span class="p">,</span><span class="n">cou_strength</span><span class="p">,</span><span class="n">temperature</span><span class="p">,</span><span class="n">N_cut</span><span class="p">,</span><span class="n">N_exp</span><span class="p">,</span><span class="n">cut_freq</span><span class="p">)</span>
<span class="n">output</span><span class="o">=</span><span class="n">heom</span><span class="o">.</span><span class="n">HSolverDL</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">HEOM1</span><span class="p">,</span><span class="n">rho0</span><span class="p">,</span><span class="n">tlist</span><span class="p">)</span>
<span class="n">qt</span><span class="o">.</span><span class="n">qsave</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="s1">&#39;HEOM1&#39;</span><span class="p">)</span></code></pre></div>
<p>由于计算时间较长，一般需要对结果进行保存。可以得到动力学以及纠缠的演化</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">HEOM1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">qload</span><span class="p">(</span><span class="s1">&#39;HEOM1&#39;</span><span class="p">)</span>
<span class="n">rho_11</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="n">HEOM1</span><span class="o">.</span><span class="n">states</span><span class="p">,</span><span class="n">num1</span><span class="p">)</span>
<span class="n">rho_22</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="n">HEOM1</span><span class="o">.</span><span class="n">states</span><span class="p">,</span><span class="n">num2</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">entanglement
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">en1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tlist</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tlist</span><span class="p">):</span>
    <span class="n">en1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">concurrence</span><span class="p">(</span><span class="n">HEOM1</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">plot the result
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">HEOM1</span><span class="o">.</span><span class="n">times</span><span class="p">,</span><span class="n">rho_11</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">HEOM1</span><span class="o">.</span><span class="n">times</span><span class="p">,</span><span class="n">rho_22</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">HEOM1</span><span class="o">.</span><span class="n">times</span><span class="p">,</span><span class="n">en1</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Times&#39;</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">((</span><span class="s2">&#34;rho_11&#34;</span><span class="p">,</span><span class="s2">&#34;rho_22&#34;</span><span class="p">,</span><span class="s2">&#34;entanglement&#34;</span><span class="p">));</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s2">&#34;rho&#34;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/HEOM_img2.png" alt="img2" /></p>
]]></content>
		</item>
		
		<item>
			<title>QuTip:time_correlation</title>
			<link>https://boseliao.github.io/posts/qutiptime_correlation/</link>
			<pubDate>Tue, 19 May 2020 19:12:13 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qutiptime_correlation/</guid>
			<description>QuTip计算时间关联函数$$\langle A(t+\tau)B(t)\rangle$$可以使用以下三种态演化方程：Master-equation, Exponential series， the Monte-Carlo。
&amp;#34;&amp;#34;&amp;#34; correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver=&amp;#39;me&amp;#39;, reverse=False, args={}, options=&amp;lt;qutip.solver.Options object at 0xa7eedc2c&amp;gt;) ----- state0 : Initial state density matrix or state vector. If &amp;#39;state0&amp;#39; is &amp;#39;None&amp;#39;, then the steady state will be used as the initial state. c_ops : list of collapse operators, may be time-dependent a_op : operator A b_op : operator B. reverse : bool {False, True} If `True`, calculate :math:`\left&amp;lt;A(t)B(t+\tau)\right&amp;gt;` instead of :math:`\left&amp;lt;A(t+\tau)B(t)\right&amp;gt;`.</description>
			<content type="html"><![CDATA[

<p>QuTip计算时间关联函数$$\langle A(t+\tau)B(t)\rangle$$可以使用以下三种态演化方程：Master-equation, Exponential series， the Monte-Carlo。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver=&#39;me&#39;,
</span><span class="s2">reverse=False, args={}, options=&lt;qutip.solver.Options object at 0xa7eedc2c&gt;)
</span><span class="s2">-----
</span><span class="s2">state0 : Initial state density matrix or state vector. If &#39;state0&#39; is &#39;None&#39;,
</span><span class="s2">         then the steady state will be used as the initial state. 
</span><span class="s2">c_ops : list of collapse operators, may be time-dependent
</span><span class="s2">a_op : operator A   b_op : operator B.
</span><span class="s2">reverse : bool {False, True}
</span><span class="s2">        If `True`, calculate :math:`\left&lt;A(t)B(t+</span><span class="se">\t</span><span class="s2">au)</span><span class="se">\r</span><span class="s2">ight&gt;` instead of
</span><span class="s2">        :math:`\left&lt;A(t+</span><span class="se">\t</span><span class="s2">au)B(t)</span><span class="se">\r</span><span class="s2">ight&gt;`.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">+</span><span class="n">a</span>
<span class="n">H</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span>
<span class="c1">#steadystate correlatin function</span>
<span class="n">corr1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">correlation_2op_1t</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">times</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> 
<span class="n">alpha</span><span class="o">=</span><span class="mf">2.5</span>
<span class="n">rho0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
<span class="c1">#no-steadystate correaltion function</span>
<span class="n">corr2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">correlation_2op_2t</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">rho0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">times</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">],</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span></code></pre></div>
<p>计算时间关联函数对应的能谱$$S(\omega)=\int_{-\infty}^{\infty}\langle A(t+\tau)B(t)\rangle e^{i\omega\tau}d\tau$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">the emission power spectrum
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">N</span><span class="o">=</span><span class="mi">4</span> <span class="c1">#number of cavityfock state</span>
<span class="n">wc</span><span class="o">=</span><span class="n">wa</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="c1">#cavity and atom frequent</span>
<span class="n">g</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="c1">#coupling strength</span>
<span class="n">kappa</span><span class="o">=</span><span class="mf">0.75</span> <span class="c1">#cavity dissipation rate</span>
<span class="n">gamma</span><span class="o">=</span><span class="mf">0.25</span> <span class="c1">#atom dissipation rate</span>
<span class="c1">#Jaynes-Cummings Hamiltonian</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">sm</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">H</span><span class="o">=</span><span class="n">wc</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">wa</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="o">+</span><span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">sm</span><span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>
<span class="c1">#collapse operaturs</span>
<span class="n">n_th</span><span class="o">=</span><span class="mf">0.25</span>
<span class="n">c_op</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n_th</span><span class="p">))</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="o">*</span><span class="n">n_th</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">*</span><span class="n">sm</span><span class="p">]</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">calculate the correlation function using the mesolve solver, and then fft to
</span><span class="s2">obtain the spectrum. Here we need to make sure to evaluate the correlation
</span><span class="s2">function for a sufficient long time and sufficiently high sampling rate so
</span><span class="s2">that the discrete Fourier transform (FFT) captures all the features in the
</span><span class="s2">resulting spectrum.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">tlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">corr</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">correlation_2op_1t</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">tlist</span><span class="p">,</span><span class="n">c_op</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span><span class="n">a</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">spectrum_correlation_fft(tlist, y, inverse=False)
</span><span class="s2">    Calculate the power spectrum corresponding to a two-time correlation
</span><span class="s2">    function using FFT.
</span><span class="s2">    ------------------
</span><span class="s2">tlist : array_like
</span><span class="s2">        list/array of times :math:`t` which the correlation function is given.
</span><span class="s2">    y : array_like
</span><span class="s2">        list/array of correlations corresponding to time delays 
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">wlist1</span><span class="p">,</span><span class="n">spec1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">spectrum_correlation_fft</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span><span class="n">corr</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">calculate the power spectrum using spectrum, which internally uses essolve
</span><span class="s2">to solve for the dynamics (by default)
</span><span class="s2">---------------------------------------
</span><span class="s2">spectrum(H, wlist, c_ops, a_op, b_op, solver=&#39;es&#39;, use_pinv=False)
</span><span class="s2">    Calculate the spectrum of the correlation function
</span><span class="s2">    i.e., the Fourier transform of the correlation function:
</span><span class="s2">        S(\omega) = \int_{-\infty}^{\infty}
</span><span class="s2">        \lim_{t </span><span class="se">\t</span><span class="s2">o \infty} \left&lt;A(t+</span><span class="se">\t</span><span class="s2">au)B(t)</span><span class="se">\r</span><span class="s2">ight&gt;
</span><span class="s2">        e^{-i\omega</span><span class="se">\t</span><span class="s2">au} d</span><span class="se">\t</span><span class="s2">au.
</span><span class="s2">        -----------------------------------------------
</span><span class="s2">wlist : list of frequencies for :math:`\omega`.
</span><span class="s2">c_ops : list of collapse operators.
</span><span class="s2">a_op : operator A.     b_op : operator B.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">wlist2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">1.75</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">spec2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">spectrum</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">wlist2</span><span class="p">,</span><span class="n">c_op</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># plot the spectra</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wlist1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span><span class="n">spec1</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;me+fft method&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wlist2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span><span class="n">spec2</span><span class="p">,</span><span class="s1">&#39;r--&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;eseries method&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Power spectrum&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;vacuum Rabi splitting&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">wlist2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span><span class="n">wlist2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/time_cor_img1.png" alt="img1" /></p>

<p>态的保真度计算</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">density matrix
</span><span class="s2">fidelity,tracedist,hellinger.dist
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">ketdm</span><span class="o">=</span><span class="n">ket</span><span class="o">*</span><span class="n">ket</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="n">qt</span><span class="o">.</span><span class="n">fidelity</span><span class="p">(</span><span class="n">ketdm</span><span class="p">,</span><span class="n">ketdm</span><span class="p">)</span>
<span class="n">qt</span><span class="o">.</span><span class="n">tracedist</span><span class="p">(</span><span class="n">ketdm</span><span class="p">,</span> <span class="n">ketdm</span><span class="p">)</span>
<span class="n">qt</span><span class="o">.</span><span class="n">hellinger_dist</span><span class="p">(</span><span class="n">ketdm</span><span class="p">,</span> <span class="n">ketdm</span><span class="p">)</span></code></pre></div>
<h2 id="量子算符的可视化">量子算符的可视化</h2>

<p>算符的存储与调取</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">storing and loading
</span><span class="s2">almost any object can be stored and load(include Qobj and Result)
</span><span class="s2">!!!!but “qsave，qload” the file format used is only understood by QuTiP (python) programs.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="n">H</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="n">c_op</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()]</span>
<span class="n">rho_ss</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">steadystate</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">c_op</span><span class="p">)</span>
<span class="n">qt</span><span class="o">.</span><span class="n">qsave</span><span class="p">(</span><span class="n">rho_ss</span><span class="p">,</span><span class="s1">&#39;steadystate&#39;</span><span class="p">)</span>
<span class="n">rho_ss_load</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">qload</span><span class="p">(</span><span class="s1">&#39;steadystate&#39;</span><span class="p">)</span>
<span class="n">qt</span><span class="o">.</span><span class="n">file_data_store</span><span class="p">(</span><span class="s1">&#39;steadystate.dat&#39;</span><span class="p">,</span><span class="n">rho_ss</span><span class="p">)</span>
<span class="n">rho_ss2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">file_data_read</span><span class="p">(</span><span class="s1">&#39;steadystate.dat&#39;</span><span class="p">)</span></code></pre></div>
<p>直方图体现了量子态在“Fock state”上的分布概率</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Visualization of quantum states and processes
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">N</span><span class="o">=</span><span class="mi">20</span>
<span class="n">rho_coherence</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">coherent_dm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">rho_thermal</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">thermal_dm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">rho_fock</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">fock_dm</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">histogram
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">bar0</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="n">rho_coherence</span><span class="o">.</span><span class="n">diag</span><span class="p">())</span>
<span class="n">lbl0</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&#34;coherence state&#34;</span><span class="p">)</span>
<span class="n">lim0</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="n">N</span><span class="p">])</span>
<span class="c1">#-------------------------------</span>
<span class="n">bar1</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="n">rho_thermal</span><span class="o">.</span><span class="n">diag</span><span class="p">())</span>
<span class="n">lbl1</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&#34;thermal state&#34;</span><span class="p">)</span>
<span class="n">lim1</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="n">N</span><span class="p">])</span>
<span class="c1">#--------------------------------</span>
<span class="n">bar2</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="n">rho_fock</span><span class="o">.</span><span class="n">diag</span><span class="p">())</span>
<span class="n">lbl2</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&#34;fock state&#34;</span><span class="p">)</span>
<span class="n">lim2</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="n">N</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/time_cor_img2.png" alt="img3" /></p>

<p>利用“Wigner Function”在相空间描绘量子态</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">wigner function
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">xvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>
<span class="n">W_coherence</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="n">rho_coherence</span><span class="p">,</span><span class="n">xvec</span><span class="p">,</span><span class="n">xvec</span><span class="p">)</span>
<span class="n">W_thermal</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="n">rho_thermal</span><span class="p">,</span><span class="n">xvec</span><span class="p">,</span><span class="n">xvec</span><span class="p">)</span>
<span class="n">W_fock</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="n">rho_fock</span><span class="p">,</span><span class="n">xvec</span><span class="p">,</span><span class="n">xvec</span><span class="p">)</span>
<span class="c1">#plot the result</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">cont0</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span><span class="n">xvec</span><span class="p">,</span><span class="n">W_coherence</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">lbl0</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&#34;coherence state&#34;</span><span class="p">)</span>
<span class="c1">#--------------------------------------</span>
<span class="n">cont1</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span><span class="n">xvec</span><span class="p">,</span><span class="n">W_thermal</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">lbl1</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&#34;thermal state&#34;</span><span class="p">)</span>
<span class="c1">#-------------------------------------</span>
<span class="n">cont2</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span><span class="n">xvec</span><span class="p">,</span><span class="n">W_fock</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">lbl0</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&#34;fock state&#34;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>
<p><img src="/img/time_cor_img3.png" alt="img3" /></p>

<p>使用“Wigner colormap”配色</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">wigner colormap
</span><span class="s2">colors all negative values differently than positive or zero values
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">wmap</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">wigner_cmap</span><span class="p">(</span><span class="n">W_coherence</span><span class="p">)</span> <span class="c1">#generate a wigner colormap</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt1</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">xvec</span><span class="p">,</span> <span class="n">W_coherence</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">wmap</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&#34;Wigner Colormap&#34;</span><span class="p">)</span>
<span class="n">cb1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">plt1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>QuTip:含时系统</title>
			<link>https://boseliao.github.io/posts/qutip%E5%90%AB%E6%97%B6%E7%B3%BB%E7%BB%9F/</link>
			<pubDate>Mon, 18 May 2020 15:10:50 +0800</pubDate>
			
			<guid>https://boseliao.github.io/posts/qutip%E5%90%AB%E6%97%B6%E7%B3%BB%E7%BB%9F/</guid>
			<description>前面已经简单的介绍过关于含时Lindblad主方程的求解，以及含时的哈密顿量和跃迁算符的表示。相应的，Bloch-Redfield含时的主方程也可以做类似求解，
kappe=0.5 def co1_coeff(t,args): return np.sqrt(kappe*np.exp(-t)) N=10 a=qt.destroy(N) H0=a.dag()*a H1=a+a.dag() def H1_coeff(t,args): return 9*np.exp(-(t/5.0)**2) H=[H0,[H1,H1_coeff]] psi0=qt.basis(N,9) c_ops=[a,[a,co1_coeff]] times=np.linspace(0.0,10.0,100) output=qt.mesolve(H,psi0,times,c_ops,[a.dag()*a]) #time-dependt Lindblad equation a_ops=[[(a,a.dag()),(&amp;#39;{0}*(w&amp;gt;0)&amp;#39;.format(kappe),&amp;#39;exp(1j*t)&amp;#39;,&amp;#39;exp(-1j*t)&amp;#39;)]] out2=qt.brmesolve(H0,psi0,times,a_ops,e_ops=[a.dag()*a]) #time-dependt Redfield equation 除此之外，当含时的参数是非解析的函数或者由实验得到的数据点时，需要将数据点变成函数。
t=np.linspace(-15,15,100) func=lambda t: 9*np.exp(-(t/5)**2) #anonymous functions noisy_func=lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]) #generary a random array shape like t,Standard normal distribution noisy_data=noisy_func(t) S=qt.interpolate.Cubic_Spline(t[0],t[-1],noisy_data) H=[[H1,S]] 含时算符的指数级数表示$$\hat{A}=\sum_i\hat{a}e^{r_it}$$
&amp;#34;&amp;#34;&amp;#34; Exponential-series representation &amp;#34;&amp;#34;&amp;#34; es1=qt.eseries(qt.sigmax(),1j) #sigma_x*exp(jt) es2=qt.eseries([qt.sigmax(),qt.sigmax()],[1j,-1j])#sigms_x*exp(jt)+sigma_xexp(-jt) &amp;#34;&amp;#34;&amp;#34; evaluate it at time t=2 &amp;#34;&amp;#34;&amp;#34; qt.esval(es2,2.0) Floquet理论 在Lindblad和Bloch-Redfield主方程的标准推导中，所考虑的系统是不显含时时间的。因此，严格地说，这些主方程形式不应盲目地应用于含时哈密顿量的系统。然而，在许多特定的情况下，特别是对于弱驱动的情况，标准主方程仍然适用于许多含时的问题。但更严格的方法是从含时的哈密顿量开始重新推导主方程。Floquet-Markov主方程是这样一种形式的主方程，它在强驱动系统中有着重要的应用。
封闭系统的Floquet计算方法$$\psi(t)=\sum_{\alpha}c_{\alpha}\psi_{\alpha}(t)=\sum_{\alpha}c_{\alpha}e^{-i\epsilon_{\alpha}t}\phi_{\alpha}(t)$$
其中\psi_{\alpha}​表示“Floquet state”，\phi_{\alpha}表示周期的“Floquet mode”，\phi_{\alpha}(t+T)=\phi_{\alpha}(t)​，\epsilon_{\alpha}表示常数“quasienergy”</description>
			<content type="html"><![CDATA[

<p>前面已经简单的介绍过关于含时Lindblad主方程的求解，以及含时的哈密顿量和跃迁算符的表示。相应的，Bloch-Redfield含时的主方程也可以做类似求解，</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">kappe</span><span class="o">=</span><span class="mf">0.5</span>
<span class="k">def</span> <span class="nf">co1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappe</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>
<span class="n">N</span><span class="o">=</span><span class="mi">10</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">H0</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span>
<span class="n">H1</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="mf">5.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="n">c_ops</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">,[</span><span class="n">a</span><span class="p">,</span><span class="n">co1_coeff</span><span class="p">]]</span>
<span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">c_ops</span><span class="p">,[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">])</span> <span class="c1">#time-dependt Lindblad equation</span>
<span class="n">a_ops</span><span class="o">=</span><span class="p">[[(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()),(</span><span class="s1">&#39;{0}*(w&gt;0)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kappe</span><span class="p">),</span><span class="s1">&#39;exp(1j*t)&#39;</span><span class="p">,</span><span class="s1">&#39;exp(-1j*t)&#39;</span><span class="p">)]]</span>
<span class="n">out2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">brmesolve</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">a_ops</span><span class="p">,</span><span class="n">e_ops</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">])</span> 
<span class="c1">#time-dependt Redfield equation</span></code></pre></div>
<p>除此之外，当含时的参数是非解析的函数或者由实验得到的数据点时，需要将数据点变成函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">t</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">9</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#anonymous functions</span>
<span class="n">noisy_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">0.05</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
<span class="c1">#generary a random array shape like t,Standard normal distribution</span>
<span class="n">noisy_data</span><span class="o">=</span><span class="n">noisy_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">S</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">Cubic_Spline</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">noisy_data</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="p">[[</span><span class="n">H1</span><span class="p">,</span><span class="n">S</span><span class="p">]]</span></code></pre></div>
<p>含时算符的指数级数表示$$\hat{A}=\sum_i\hat{a}e^{r_it}$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Exponential-series representation
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">es1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">eseries</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="mi">1j</span><span class="p">)</span> <span class="c1">#sigma_x*exp(jt)</span>
<span class="n">es2</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">eseries</span><span class="p">([</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="mi">1j</span><span class="p">,</span><span class="o">-</span><span class="mi">1j</span><span class="p">])</span><span class="c1">#sigms_x*exp(jt)+sigma_xexp(-jt)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">evaluate it at time t=2
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">qt</span><span class="o">.</span><span class="n">esval</span><span class="p">(</span><span class="n">es2</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span></code></pre></div>
<h2 id="floquet理论">Floquet理论</h2>

<p>在Lindblad和Bloch-Redfield主方程的标准推导中，所考虑的系统是不显含时时间的。因此，严格地说，这些主方程形式不应盲目地应用于含时哈密顿量的系统。然而，在许多特定的情况下，特别是对于弱驱动的情况，标准主方程仍然适用于许多含时的问题。但更严格的方法是从含时的哈密顿量开始重新推导主方程。Floquet-Markov主方程是这样一种形式的主方程，它在强驱动系统中有着重要的应用。</p>

<p>封闭系统的Floquet计算方法$$\psi(t)=\sum_{\alpha}c_{\alpha}\psi_{\alpha}(t)=\sum_{\alpha}c_{\alpha}e^{-i\epsilon_{\alpha}t}\phi_{\alpha}(t)$$</p>

<p>其中<code>\psi_{\alpha}​</code>表示“Floquet state”，<code>\phi_{\alpha}</code>表示周期的“Floquet mode”，<code>\phi_{\alpha}(t+T)=\phi_{\alpha}(t)​</code>，<code>\epsilon_{\alpha}</code>表示常数“quasienergy”</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Floquat thoery
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">eps0</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">A</span><span class="o">=</span><span class="mf">2.5</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">H0</span><span class="o">=-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">delta</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">eps0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="n">H1</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span><span class="n">omega</span><span class="p">}</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="s1">&#39;sin(w*t)&#39;</span><span class="p">]]</span>
<span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Calculate the initial Floquet modes Phi_alpha(0) for a driven system with period T.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span> 
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting
</span><span class="s2">the initial Floquet modes Phi_alpha(0)
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">t</span><span class="o">=</span><span class="mf">2.5</span>
<span class="n">f_modes_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes_t</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Decompose the wavefunction `psi` (typically an initial state) in terms of
</span><span class="s2">the Floquet states, :math:`\psi = \sum_</span><span class="se">\a</span><span class="s2">lpha c_</span><span class="se">\a</span><span class="s2">lpha \psi_</span><span class="se">\a</span><span class="s2">lpha(0)`.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">f_coeff</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_state_decomposition</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span><span class="n">psi0</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Evaluate the wavefunction for a time t using the Floquet state
</span><span class="s2">decompositon, given the initial Floquet modes.
</span><span class="s2">f_modes_0:A list of initial Floquet modes
</span><span class="s2">f_energies:The Floquet energies
</span><span class="s2">f_coeff:The coefficients for Floquet decomposition of the initial wavefunction
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
<span class="n">psi_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_wavefunction_t</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span><span class="n">f_coeff</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span></code></pre></div>
<p>耗散系统的Floquet_Markov主方程的计算方法，$$\rho_{\alpha\beta} (t)=\langle\psi_{\alpha}(t)|\rho (t)|\psi_{\beta}\rangle,n_{th}(\omega)=\frac{1}{e^{h\omega/k_B T}-1},X_{\alpha\beta}=\langle\psi_{\alpha}|A|\psi_{\beta}\rangle$$，<code>A</code>表示与环境耦合的算符</p>

<p>$$\dot{\rho}_{\alpha\beta}=\frac{1}{\pi}\int_0^{\infty}d\omega J(\omega)n_{th}(\omega)\int_0^{\infty}d\tau e^{i\omega\tau}R_{\alpha\beta}(t-\tau,t)$$</p>

<p>$$+\frac{1}{\pi}\int_0^{\infty}d\omega J(\omega)(1+n_{th}(\omega))\int_0^{\infty}d\tau e^{-i\omega\tau}R_{\alpha\beta}(t-\tau,t)$$</p>

<p>$$R_{\alpha\beta}(t-\tau,t)=\sum_{ij}\left(X_{\alpha i}(t-\tau)\rho_{ij}(t)X_{\beta j}^*+X_{i\alpha}^*X_{j\beta}(t-\tau)\rho_{ij}(t) \right)$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">floquet_markov master equation
</span><span class="s2">Note:Currently the qutip.floquet.fmmesolve can only accept a single environment 
</span><span class="s2">coupling operator and spectral-density function.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">delta</span><span class="o">=</span><span class="mf">0.0</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">eps0</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">A</span><span class="o">=</span><span class="mf">0.25</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="n">omega</span>
<span class="n">tlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mi">20</span><span class="o">*</span><span class="n">T</span><span class="p">,</span><span class="mi">101</span><span class="p">)</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H0</span><span class="o">=-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">delta</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">eps0</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="n">H1</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span><span class="n">omega</span><span class="p">}</span>
<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)]]</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">noise power spectrum
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">gamma1</span><span class="o">=</span><span class="mf">0.1</span>
<span class="k">def</span> <span class="nf">noise_spectrum</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">gamma1</span><span class="o">*</span><span class="n">omega</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">find the floquet modes for the time-dependent hamiltonian
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Pre-calculate the Floquet modes for a range of times spanning the floquet
</span><span class="s2">period. Can later be used as a table to look up the floquet modes for any time.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">f_modes_table_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes_table</span><span class="p">(</span><span class="n">f_modes_0</span><span class="p">,</span><span class="n">f_energies</span><span class="p">,</span>\
                                       <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="mi">501</span><span class="p">),</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">solve floquet_markov master equation
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">output</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">fmmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[],[</span><span class="n">noise_spectrum</span><span class="p">],</span><span class="n">T</span><span class="p">,</span><span class="n">args</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">calaulate expectation values in the computational baisi
</span><span class="s2">enumerate:It is useful for obtaining an indexed list:
</span><span class="s2">    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
</span><span class="s2">    
</span><span class="s2">transform:Input array can be a ``matrix`` defining the transformation,
</span><span class="s2">or a ``list`` of kets that defines the new basis.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">p_ex</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tlist</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tlist</span><span class="p">):</span>
    <span class="n">f_modes_t</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">floquet_modes_t_lookup</span><span class="p">(</span><span class="n">f_modes_table_t</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
    <span class="n">p_ex</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>\
        <span class="n">output</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">f_modes_t</span><span class="p">,</span><span class="bp">True</span><span class="p">))</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">for reference: calculate the same thing with mesolve
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">output1</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">psi0</span><span class="p">,</span><span class="n">tlist</span><span class="p">,[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma1</span><span class="p">)</span><span class="o">*</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()],[</span><span class="n">qt</span><span class="o">.</span><span class="n">num</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span><span class="n">args</span><span class="p">)</span>
<span class="n">p_ex_ref</span><span class="o">=</span><span class="n">output1</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code></pre></div>
<h2 id="传播子">传播子</h2>

<p>通过对角化Hamilton或Liouvillian的方法得到含时系统的传播子，并计算其时间演化$$e^{iHt}\rho e^{-iHt}$$</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Assembles the Liouvillian superoperator from a Hamiltonian
</span><span class="s2">and a ``list`` of collapse operators.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">L</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">liouvillian</span><span class="p">(</span><span class="n">H</span><span class="p">,[</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">Creates an exponential series that describes the time evolution for the
</span><span class="s2">initial density matrix (or state vector) `rho0`, given the Liouvillian
</span><span class="s2">(or Hamiltonian) `L`.
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">es</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">ode2es</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">psi0</span><span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">by evaluating it and arbitrary points in time=0.0,1.0
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">es</span><span class="o">.</span><span class="n">value</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span></code></pre></div>
<h2 id="平衡态的计算">平衡态的计算</h2>

<p>在QuTip中，可以以很高的效率寻找Lindblad主方程的平衡态</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">steady state
</span><span class="s2">solving for the steady state solution to the Lindblad master equation 
</span><span class="s2">for a general system
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="n">N</span><span class="o">=</span><span class="mi">20</span> <span class="c1">#number of basis state to consider</span>
<span class="n">a</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">H</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span>
<span class="n">psi0</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c1">#initial state</span>
<span class="n">kappa</span><span class="o">=</span><span class="mf">0.1</span> <span class="c1">#couple to oscillator</span>
<span class="c1">#callopse operators</span>
<span class="n">c_op_list</span><span class="o">=</span><span class="p">[]</span>
<span class="n">n_th_a</span><span class="o">=</span><span class="mi">2</span> <span class="c1">#temperature with average of 2 excitations</span>
<span class="n">rate</span><span class="o">=</span><span class="n">kappa</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n_th_a</span><span class="p">)</span>
<span class="k">if</span> <span class="n">rate</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
    <span class="n">c_op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="c1">#decay operators</span>
<span class="n">rate</span><span class="o">=</span><span class="n">kappa</span><span class="o">*</span><span class="n">n_th_a</span>
<span class="k">if</span> <span class="n">rate</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
    <span class="n">c_op_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span> <span class="c1">#excitation oprators</span>
<span class="c1">#find final steady-state solution</span>
<span class="n">final_state</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">steadystate</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">c_op_list</span><span class="p">)</span>
<span class="c1">#find expectation value for partical number in steady state</span>
<span class="n">fexpt</span><span class="o">=</span><span class="n">qt</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="n">final_state</span><span class="p">)</span></code></pre></div>]]></content>
		</item>
		
	</channel>
</rss>
